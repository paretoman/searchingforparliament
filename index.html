<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1">
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
                      tex2jax: {inlineMath: [['$', '$'], ['\\(','\\)']]},
                      TeX: { equationNumbers: {autoNumber: "AMS"} },
                      "HTML-CSS": { showMathMenu: false,
                                    scale: 90 }
                     });
</script>
<link rel="stylesheet" href="base.css">
<style>
#nav {
	position: static;
}

a:hover.screenshot {
  opacity: .7;
}

.site {
  fill: white;
  stroke: black;
  stroke-width: 1;
}

.client {
  fill: black;
  opacity: .5;
}

.repclass{
}
.voterclass{
}

.place,
.place-label {
  fill: black;
  opacity: 1;
  stroke: none;
}

</style>
<script>
	// "lightblue","lightgreen","tomato","yellow","orange"
	var color_fill = ["#add8e6","#90ee90","#ff6347","#ffff00","#ffa500","#65C1A5","#8D9EC9","#E68AC2","#D4BDDC","#DDCFAF","#6EA0C8","#D90015","#DE9B13","#6EA0C8","#A4D959","#198E64","#DD0076","#936219","#525252","#615AA2"];
	var color_stroke = ["#000099","#006600","#990000","#999900","#994400","black","black","black","black","black","black","black","black","black","black","black","black","black","black","black"];
</script>

<body>
<ul id="nav">
    <li class="current"><a href="#intro">Intro</a></li>
    <li><a href="#problem">Problem</a></li>
    <li><a href="#model">Model</a></li>
    <li><a href="#implementation">Implementation</a></li>
    <li><a href="#demo">Live Demo</a></li>
  </ul>
  <div id="example_container">
    <div class="example_section" id="intro">
      <h1>Searching for Parliament</h1>
        <subtitle>(the computer science kind of search)</subtitle>
    </div>
    <p>
      Selecting a group of people to represent a nation is an example of what computer science calls an assignment search problem.  Which reps (candidates) are the most representative of the voters?
    </p>

    <p>
      We'll construct a mathematical model of the assignment search problem, implement this model in the Python programming language with an optimization package called Gurobi, and compute and visualize an optimal solution.
    </p>

    <p>
      The implementation of the model and the structure of this explanation is forked from the work of Emilien Dupont (on <a href="https://github.com/EmilienDupont/facilityLocation">github</a> and hosted as <a href="http://examples.gurobi.com/facility-location/"> a featured example on Gurobi's website</a>).  The code for <a href="https://github.com/paretoman/searchingforparliament">this website is on github</a>.
    </p>

    <h3>
      Click the screenshot to skip directly to the Live Demo!
    </h3>
    <p>
      <a href="#demo" class="screenshot">
        <img src="screenshot.png" alt="Live Demo" ; vertical-align: middle;">
      </a>
    </p>


    <div class="example_section" id="problem">
      <h2><a href="#problem" name="problem">Problem Description</a></h2>

    <div style="float:right;">
      <a href="https://en.wikipedia.org">
        <img src="Sir_Gerald_Kaufman.jpg" alt="Sir_Gerald_Kaufman" style="width:200px;">
      </a>
    </div>

    <p>Northern England gets rid of district boundaries because there was too much debate about where the boundaries should go.  It wants to pick 5 reps.  And it wants to space them out instead of having them all from the middle.  It wants regional interests to be represented and it doesn't want all the seats to be taken by people from the same neighborhood in the middle of Northern England.</p>

    <p>Several good reps (lets say "reps" instead of "potential representatives" or "candidates") have decided to run, but it remains to decide which of the reps should win.</p>

        <aside> A typical rep.<span style="font-size: 10px"></span>
    </aside>

    <p>Selecting reps from the middle of Northern England would be advantageous as they would have the most votes overall.  However, voters from the middle of Northern England would be overrepresented and voters from the coast would be very far from their from their reps.</p>

    <p>We will find the optimal tradeoff between reps being near all the voters and voters having reps nearby.</p>

    <h3> Search Trees </h3>
      <p>
        Our problem is related to a very famous problem in computer science called the knapsack problem.  It differs in many ways.  It is similar in how it can be solved.  Both are kinds of binary search.  A search problem tries to find a combination of variables that is in some way the best combination.  One way to approach such a problem is the branch and bound method.  Here is a video on the <a href="https://www.coursera.org/learn/discrete-optimization/lecture/66OlO/knapsack-5-relaxation-branch-and-bound">branch and bound method</a> from a fantastic Coursera course in the field of <a href="https://www.coursera.org/learn/discrete-optimization/">discrete optimization</a>.  From this video, just understand that <b>there is a large number of possible choices to make and that they can all be organized in a tree structure</b>.  (The actual algorithm for searching through the tree will be taken care of by Gurobi, and we don't talk about it below.)  We still haven't said what the score is for each choice (or path) in the tree, so let's do that.  Most of the writing below is about that.  Each choice in the tree represents whether a rep wins.  The first split is for the first rep, the second split is for the second rep, etc.
      </p>
        <p> 
        <div style="text-align: center">
		<p>
		<img src = "./tree.png"/>
		</p>
		</div>
        </p>
      <p>
          This tree is not for the problem at hand, but our problem is similar because it has the same binary variables $x_i$.
	  </p>
    </div>

    <div class="example_section" id="model">
      <h2><a href="#model" name="model">Mathematical Model</a></h2>
      <p>
        Let us now formulate a mathematical model for our problem.
      </p>
	    
      <p>
        We need to say when we choose a rep.  Let's list all the reps as rep #1, rep #2, rep #3, etc, and let's make variables for each one.  If we choose rep #1, then $x_1=1$ and if we don't choose rep #2, then $x_2=0$.  Basically, $x_j$ is binary.
        \[
        x_j = \left\{\begin{array}{ll}
               1 & \text{if we choose rep #j, }\\
               0 & \mathrm{otherwise.}
              \end{array}\right.
        \]
		We set a constraint on the $x_j$ variables because there are only a limited number of seats in the legislature.  We set the sum of all $x_j$ to this number of seats.
        \[
        \sum_{j \in Reps} x_j = \text{number of seats}
        \]
      </p>
      <p>
        We need to say how close a voter is to a rep.  Let's list all the voters as voter #1, voter #2, etc, and let's make measurements for each voter and rep combination.  If the distance between voter #1 and rep #3 is 100 km, then $d_{13}=100$.
        \[
        d_{ij} = \text{distance between voter i and rep j}
        \]
      </p>

      <p>
        What does a ballot look like? We want to make this problem easy to show on a map so we're going to make a simplification of the problem.  We're going to let the voters give the reps scores.  This is actually nicer for the voters because they get to say what they think of every rep.  Also, we're going to make every voter use the same scoring scale, and they will base their score entirely on how far away the rep is.  Basically, the inverse of distance.
        \[
		\begin{array}{ll}
        a_{ij} & = {\displaystyle \frac{1}{d_{ij}/10 + 1} } & \text{Inverting distance}\nonumber \\
		b_{ij} & = {\displaystyle a_{ij} * \frac{1}{\max_{m \in Voters}{a_{mj}}}} &\text{Ballot normalized}  \nonumber
		\end{array}
        \]
      </p>
      <p>
        (The 10 is here for scaling distance.  The extra 1 is here to avoid dividing by 0.  Really, there are many choices for this function. One more modification we make is to let voters who don't have a very close rep vote with their full vote for their closest rep.  This normalization is here because voters would give the rep closest to them the highest score possible even if they aren't actually all that close.)
      </p>
        <div style="text-align: center">
		<p><img src="./tally.png" style="text-align: center" /></p>
		</div>
      <p>
        We need a way to count the ballots.  The easiest way is to add them together to get the reps' tallies.
        \[
        tally_j = \sum_{i \in Voters} b_{ij} 
        \]
      </p>
      <p>
        If we stop here then we just end up picking the reps in the middle because they have the highest tallies.
      </p>
      <p>
        We want to avoid overrepresenting the middle voters.  Our solution is to let the winning reps keep a fraction of their voters' ballots.  Basically, these voters have the reps, so the reps get to keep the voters.  Each winning rep keeps the same amount of support.
        \[
        keep = 
			\left[
            \begin{array}{ll}
				& \text{an amount of score,} \\
				& \text{same units as ballots} \\
				& \text{same for each pair of reps} \\
            \end{array}
			\right]
        \]
      </p>
      <p>
        The idea of the rep keeping some ballots is not new.  The election method called Single Transferable Vote (STV) does the same thing.  It is different because it doesn't use scores.  It uses ranking.  Still, it is very similar.  STV calls it a quota.  When a rep is declared a winner, he keeps a quota of votes and the extra go to other reps similar to him if the voters have both on their ballot.
        \[
        \text{STV quota} = \frac{\text{voters}}{\text{seats} + 1}
        \]
        The quota is set as the number of voters divided by the number of seats to fill with reps.  An additional 1 is added to the number of seats because of the iterative nature of STV (a longer explanation is needed).
      </p>
      <p>
        Let's try something similar:
        \[
        keep = \frac{\text{voters}}{\text{seats}}
        \]
		STV subtracts this for each pair of reps when one of the pair wins and they are supported by the same group of voters.  We want to subtract this for each similar pair, and we want to show why it selects the correct number of reps for a group of voters.
      </p>
      <h3> Mini example to show proportionality</h3>
      <p>
        Ok, we'll show an example.  We can actually see the method at work.

	    \[
        \begin{align}
        3& \text{ seats} \nonumber \\
        6& \text{ voters} \nonumber \\
        2& \text{ voters for party A: A1,A2,A3,...} \nonumber \\
        4& \text{ voters for party B: B1,B2,B3,...} \nonumber \\
        \end{align}
        \]
		
		Here are the ballots for just the parties:
				\[
		\begin{bmatrix}
		A: & 1 & 1 & 0 & 0 & 0 & 0 \\
		B: & 0 & 0 & 1 & 1 & 1 & 1 
		\end{bmatrix}
		\]
		
		Here are the tallies for each of the reps:
		\[
		\begin{bmatrix}
		A_1: & 2 \\
		A_2: & 2 \\
		B_1: & 4 \\
		B_2: & 4 \\
		\end{bmatrix}
		\]
		
		We can also write the tallies along the diagonals of this table
		
		\[
            \begin{bmatrix}
				      &A_1 &A_2 &B_1 &B_2  \\
                 A_1: &  2 &    &    &     \\
                 A_2: &    &  2 &    &     \\
                 B_1: &    &    &  4 &     \\
                 B_2: &    &    &    &  4  \\
            \end{bmatrix}
        \]
		
		Keeps happen when two reps from the same party get elected.  For every pair, there is a table entry, so lets fill in those entries with keeps.  
		
        \[
        keep = \frac{\text{voters}}{\text{seats}} = \frac{\text{6}}{\text{3}} = 2
        \]
		There are two table entries for each pair, so we divide this $keep$ between them.
		\[
			\left[
            \begin{array}{rr}
				      &A_1 &A_2 &B_1 &B_2  \\
                 A_1: &  2 & -1 &    &     \\
                 A_2: & -1 &  2 &    &     \\
                 B_1: &    &    &  4 & -1  \\
                 B_2: &    &    & -1 &  4  \\
            \end{array}
			\right]
        \]
		
		We want to choose the 3 reps with the most votes.  So we try each combination, and for each we add the tallies and subtract the keeps.
		</p>
		<p>
		1 from A and 2 from B is the best combination:
		\[
			\left[
            \begin{array}{rr}
				      &A_1 &  \text{   }  &B_1 &B_2  \\
                 A_1: &  2 &    &    &     \\
                      &    &    &    &     \\
                 B_1: &    &    &  4 & -1  \\
                 B_2: &    &    & -1 &  4  \\
            \end{array}
			\right] = 2+4+4-1-1=8
        \]
		The keeps can be drawn on a Venn diagram.  There are 4 voters here.  First take 1 from the shared voter pool for one rep.  Then take 1 for the other.
		</p>
		<p>
		<div style="text-align: center">
		<p>
		<img src="venndiagram.png"  style="text-align: center" />
		</p>
		</div>
		</p>
		<p>
		2 from A is not as good because there are a disproportionate number from A:
		\[
			\left[
            \begin{array}{rr}
				      &A_1 &A_2 &B_1 & \text{   }  \\
                 A_1: &  2 & -1 &    &     \\
                 A_2: & -1 &  2 &    &     \\
                 B_1: &    &    &  4 &     \\
                      &    &    &    &     \\
            \end{array}
			\right] =2+2+4-1-1=6
        \]
		If there were 3 winners from B, the total votes would be even less.  
		\[
			\left[
            \begin{array}{rr}
				      &    &  \text{   }  &B_1 &B_2& B_3  \\
                      &    &    &    &    &     \\
                      &    &    &    &    &     \\
                 B_1: &    &    &  4 & -1 & -1  \\
                 B_2: &    &    & -1 &  4 & -1  \\
                 B_3: &    &    & -1 & -1 & 4  \\
            \end{array}
			\right] = 4+4+4-1-1-1-1-1-1=6
        \]
		The best combination was when there the proportion of votes matched the proportion of seats.  <b>That means the way we count votes is proportional.</b>  Also notice we lost 2 points whether we went forward or back, so we're right on the maximum.  We can get proportionality by just maxmizing the sum of this table.  We also gained a nice table graphic for counting votes.
		</p>
	  <h3> Proportionality </h3>
	  <p>
	    Lets do some maximization to show that this is the right number of keeps.  It might seem that each rep should hold on to the keeps rather than splitting them.  So we will find out if the amount of keeps should be some other number.
		
	    \[
        \begin{align}
        C_t& \text{ seats} \nonumber \\
        N_t& \text{ voters} \nonumber \\
        N_A& \text{ voters for party A: A1,A2,A3,...} \nonumber \\
        N_B& \text{ voters for party B: B1,B2,B3,...} \nonumber \\
		C_A& \text{ number of winners for party A} \nonumber \\
        C_B& \text{ number of winners for party B} \nonumber \\
        \end{align}
        \]
		
		For each party, let's look at the winners add the tallies and subtract the keeps:
		
				\[
			\left[
            \begin{array}{rr}
				      & A_1 & A_2 & \text{...} & A_{C_A}  \\
                 A_1: & N_A &  -K/2 &     &   -K/2   \\
                 A_2: &  -K/2 & N_A &     &   -K/2   \\
                 \text{...} &     &     &     &        \\
                 A_{C_A}:  &  -K/2 &  -K/2 &     & N_A    \\
            \end{array}
			\right] = N_A*C_A-\frac{1}{2}K*C_A*(C_A-1)
			\]
		For both parties, 
			\[
				Obj = N_A*C_A-\frac{1}{2}K*C_A*(C_A-1) + N_B*C_B-\frac{1}{2}K*C_B*(C_B-1) 
			\]
		Let's maximize this objective function on $C_A$ by setting its derivative to $0$ and solving for $K$:
		\[
			\begin{align}
			\frac{d \ Obj}{d \ C_A} &= 0 \nonumber \\ \nonumber \\
			0 &= N_A-N_B-K*C_A+K*C_B \nonumber \\ \nonumber \\
			K &= \frac{N_A-N_B}{C_A-C_B} \nonumber
			\end{align}
		\]
		Now lets enforce proportionality. Proportionality means every party has the same number of voters per rep:
		\[
		\frac{N_A}{C_A}=\frac{N_B}{C_B}=\frac{N_t}{C_t}
		\]
		So we substitute and do algebra to get a confirmation of what we already guessed.
		\[
			K  =\frac{N_A-N_B}{C_A-C_B}=\frac{N_t}{C_t}=\frac{\text{voters}}{\text{seats}} \nonumber \\
		\]
		\[
			keep =\frac{\text{voters}}{\text{seats}} \nonumber
        \]
		So we know we have a proportional system.
      </p>
      <h3> Finishing the Model: Similarity </h3>
      <p>
        What if the voters don't fall into parties?
      </p>
      <p>
	  A party is just a group of people who vote the same.  Take an example.  Say rep A and B say they are from different parties.  What if a voter votes for both?  How do we account for proportionality?
		</p>
        <p>
		Take an example of 3 voters.  One for A, one for B, and one for both:
		\[
		\text{A partisan voter for A: } \
		\begin{bmatrix}
		A: & 1 \\
		B: & 0 
		\end{bmatrix}
		\]
		\[
		\text{A partisan voter for B: } \
		\begin{bmatrix}
		A: & 0 \\
		B: & 1 
		\end{bmatrix}
		\]
		\[
		\text{A voter for A and B: } \
		\begin{bmatrix}
		A: & 1 \\
		B: & 1 
		\end{bmatrix}
		\]
		Let's look at all the ballots together.  We have 3 kinds of voter.  1 out of 3 treats A and B as a single party.  It is like A and B are part of the same party, the AB party:
		\[
		\text{Three voter pools: } \
		\begin{bmatrix}
		A: & 1 & 1 & 0 \\
		B: & 0 & 1 & 1 
		\end{bmatrix}
		\quad \rightarrow
		\begin{bmatrix}
		AB: & 1 \\
		A:  & 1 \\
		B:  & 1 \\
		\end{bmatrix}
		\]
		How do we account for this in our bookkeeping about kept votes?  1/3 of the votes for A or B were for both A and B.  So we reduce the number of kept votes to 1/3 of the usual.
		\[
		\frac{1}{3} = \frac{0 + 1 + 0}{1 + 1 + 1}
		\]
		This measure is actually common.  It is called the Jaccard similarity.  Stated mathematically,
        \[
		\begin{align}
		 \nonumber \\
s_{jk} & = \frac{\sum_{i \in Voters} min(b_{ij}, b_{ik})}{\sum_{i \in Voters} max(b_{ij}, b_{ik})} \text{ } \text{ } \text{ } \text{ (Similarity between rep j and rep k)}\nonumber \\
		\end{align}
        \]
		<h4> Mixture Example</h4>
		Let's try to justify this more and build an intuition by working through an example:
		\[
		\text{mixture example: } \
		\begin{bmatrix}
		A: & 1 & 1 & 1 & 1 & 0 & 0 \\
		B: & 0 & 0 & 1 & 1 & 1 & 1 
		\end{bmatrix}
		\quad \rightarrow
		\begin{bmatrix}
		AB: & 2 \\
		A:  & 2 \\
		B:  & 2 \\
		\end{bmatrix}
		\]
		This is actually a mixture of two extremes.  A 1-party extreme where A and B are actually from the same party, and a 2 party extreme where A and B are from different parties:
		
		\[
		\text{1-party extreme: } \
		\begin{bmatrix}
		A: & 1 & 1 & 1 & 1 & 1 & 1 \\
		B: & 1 & 1 & 1 & 1 & 1 & 1 
		\end{bmatrix}
		\quad \rightarrow
		\begin{bmatrix}
		AB: & 6 \\
		A:  & 0 \\
		B:  & 0 \\
		\end{bmatrix}
		\]
		
		\[
		\text{2-party extreme: } \
		\begin{bmatrix}
		A: & 1 & 1 & 1 & 0 & 0 & 0 \\
		B: & 0 & 0 & 0 & 1 & 1 & 1 
		\end{bmatrix}
		\quad \rightarrow
		\begin{bmatrix}
		AB: & 0 \\
		A:  & 3 \\
		B:  & 3 \\
		\end{bmatrix}
		\]
		Across both extreme examples, the same number of candidates win from each party.  So the middle example should have the same result. 
		\[
		\text{different examples, same result: } \
		\begin{bmatrix}
		    & \text{2P:} & \text{M:} & \text{1P:}\\
		AB: & 0 & 2 & 6 \\
		A:  & 3 & 2 & 0 \\
		B:  & 3 & 2 & 0 \\
		\end{bmatrix}
		\]
		A test with Jaccard similarity would show that maximizing the table sum gives the same composition of winners.  Let's now see how we would write up this test.
		<h4> Add Similarity to Model </h4>
		Let's include this similarity measure in our model.  We need to adjust the number of votes that are kept when a pair of candidates share the same voter support:
		\[
		keeps_{jk} = keep * s_{jk} \nonumber
		\]
		We only do this when both reps win.  We want to make an indicator for when both reps win.  Remember the $x$ is binary and it indicates the winners.
		\[
		\begin{array}{l}
			x_j * x_k & \text{Indicates when both reps have won}
			\end{array}
			\]
        We can now refine our model to maximize the following, called an objective function:
		\[
        \text{Maximize} \sum_{j \in Reps} tally_j * x_j - \sum_{j \in Reps,k \neq j} \frac{1}{2} keeps_{jk} * x_j * x_k
        \]
         This expression is just the sum of the table, so it's basically just letting us add up the tally and subtract the keeps for the winning reps. The 1/2 factor is in there because there are 2 entries $x_{jk}$ and $x_{kj}$ for each pair.  So! <b>We have a new and better table to add up and maximize!  It is better because now we don't need parties!  It's the voters that matter, not the parties.</b>
      </p>
	  <h3> The model is actually like a sudoku </h3>
      <p>
        There is a really easy way to visualize what the model is trying to do.  We reduced the problem to crossing out the rows and columns in a table.  Cross out the row and column for each rep that lost. Add the remaining tallies and keeps.  Try to find the 4 winners by crossing out the losing rep's row and column.
        \[
          \begin{bmatrix}
        10 & -4 & -3 &  0 & -1 \\
        -4 & 10 & -3 &  0 & -1 \\
        -3 & -3 &  8 & -2 &  0 \\
         0 &  0 & -2 & 11 &  0 \\
        -1 & -1 &  0 &  0 & 17 \\
          \end{bmatrix}
        \]
      The solution is to cross out the 3rd rep's row and column.  He had the lowest tally overall and he also overlapped in similarity with most of the other reps, so basically his territory was covered better by the other reps.
      </p>
      <p>
	  <div style="text-align: center">
	  <p>
      <img src="./crossout.png"  style="text-align: center" />
	  </p>
	  </div>
      </p>
	  <h3>Formal Model</h3>
      <p>
        To sum up, the model maximizes a sum of linear and quadratic terms involving binary variables $x_j$ and a table of measurements.  There is a constraint that there are a specified number of winners.  Gurobi takes care of the search algorithm to find the maximum among a really large number of combinations (think factorial!).
      </p>
      <p>
        The problem is defined by the following model in the variable $x_j$ :

        \[
        \begin{array}{ll}
        \text{Maximize}   & {\displaystyle \sum_{j \in Reps} tally_j * x_j - \sum_{j \in Reps,k \neq j} \frac{1}{2} keeps_{jk} * x_j * x_k } \\
		\\
        \text{Subject to} & {\displaystyle \sum_{j \in Reps} x_j} = \text{number of seats} \\
                          & x_j \in \{ 0, 1 \} \\
						  \\
        \end{array}
		\\
        \begin{array}{lrll}
        \text{Constants } & keeps_{jk} & = keep * s_{jk}& \text{Rep j keeps these votes from rep k}\\ \\
                          & s_{jk} & = {\displaystyle \frac{\sum_{i \in Voters} min(b_{ij}, b_{ik})}{\sum_{i \in Voters} max(b_{ij}, b_{ik})} }& \text{Similarity between reps j and k} \nonumber \\ \\
                          & keep & = {\displaystyle \frac{\text{voters}}{\text{seats}} } & \text{Amount of ballots kept (if s=1, e.g. for clones)}\\ \\
                          & tally_j & = {\displaystyle \sum_{i \in Voters} b_{ij} } & \text{Add up the ballots}\\ \\
						  & b_{ij} & = {\displaystyle a_{ij} * \frac{1}{\max_{m \in Voters}{a_{mj}}}} &\text{Ballot} \\ \\
						  & a_{ij} & = {\displaystyle \frac{1}{d_{ij}/10 + 1} } & \text{Inverting distance}\\ \\
                          & d_{ij} &  & \text{Distance between voter i and rep j on the map}
        \end{array}
        \]

      </p>

    </div>
    <div class="example_section" id="implementation">
      <h2><a href="#implementation" name="implementation">Implementation</a></h2>
      <p>Below is an example implementation of the model with example data in
        Gurobi's Python interface:
      </p>
        <p>
            For the full implementation, see <a href="https://github.com/paretoman/searchingforparliament">https://github.com/paretoman/searchingforparliament</a>.
        </p>
      <p> Here is a link to Gurobi.  I kept it here because I forked this project from Emilien Dupont (on <a href="https://github.com/EmilienDupont/facilityLocation">github</a> and hosted as <a href="http://examples.gurobi.com/facility-location/"> a featured example on Gurobi's website</a>)
      </p>
      <div class="col_5 column">
        <a href="http://www.gurobi.com/downloads/evaluation-request">
          <button class="red stack-button">
            <i class="fa fa-lg fa-line-chart"></i>
            Commercial Users: Free Evaluation Version
          </button>
        </a>
      </div>
      <div class="col_5 column">
        <a href="http://www.gurobi.com/downloads/download-center">
          <button class="red stack-button">
            <i class="fa fa-lg fa-line-chart"></i>
            Academic Users: Free Academic Version
          </button>
        </a>
	  </div>
	  <p>
      I suggest using conda to install it.  And then there is a license to download, so you have to make an account on the gurobi website.  I used Python 2.
      </p>
      
<examplecode>
from gurobipy import *
import math
import numpy

# Problem data
voters = [[c1,c2] for c1 in range(10) for c2 in range(10)]
reps = [[f1*3+1.5,f2*3+1.7] for f1 in range(3) for f2 in range(3)]
numReps = len(reps)
numVoters = len(voters)

# Add variables
m = Model()
x = {}
for j in range(numReps):
    x[j] = m.addVar(vtype=GRB.BINARY, name="x%d" % j)

# Add constants
numWinners = 5
d = numpy.zeros((numVoters,numReps))
a = numpy.zeros((numVoters,numReps))
b = numpy.zeros((numVoters,numReps))
s = numpy.zeros((numReps,numReps))
t = numpy.zeros(numReps)

def distance(a,b):
    dx = a[0] - b[0]
    dy = a[1] - b[1]
    return math.sqrt(dx*dx + dy*dy)

for i in range(numVoters):
    for j in range(numReps):
        d[i,j] = distance(voters[i], reps[j])

a = 1 /( d/10 + 1 )

for i in range(numVoters):
	b[i,:] = a[i,:] / max(a[i,:])

keep = numVoters / numWinners

def jaccard_similarity(a,b):
    return numpy.sum(numpy.minimum(a,b)) / numpy.sum(numpy.maximum(a,b))
			
for j in range(numReps):
    t[j] = sum(b[:,j])
    for k in range(numReps):
        s[j,k] = jaccard_similarity(b[:,j],b[:,k])

m.update()

# Add constraints
m.addConstr(quicksum(x[j] for j in range(numReps)) == numWinners)

d_obj = LinExpr()
for j in range(numReps):
    d_obj += t[j]*x[j]
    for k in range(numReps):
        if k != j:
            d_obj += -.5*keep*s[j,k]*x[j]*x[k]

m.setObjective( d_obj , GRB.MAXIMIZE)

m.optimize()

# Output
print(["%d" % x[j1].X for j1 in range(9)])

</examplecode>
    </div>
    <div class="example_section" id="demo">
      <h2><a href="#demo" name="demo">Live Demo</a></h2>

      <p>
        Below is a visualization of our example. We are using the
        location data from <a href="#geolytix">GeoLytix</a> for a large
        supermarket chain in the UK, and visualizing its outlets in
        Northern England. (This is an approximation to population distribution.)
      </p>

      <p>
        The voters are represented by:
        <svg height="20" width="20">
      <circle cx="10" cy="15" r="3" fill="black" opacity=".5" />
    </svg>
      </p>

      <p>
        By clicking the map you can add rep locations.
        These are drawn as:
        <svg height="20" width="20">
      <circle cx="10" cy="10" r="8" stroke="black" stroke-width="1" fill="white" />
    </svg>
      </p>
      <p>
        Click "Compute Winners" to find the winners. These will be drawn as:
        <svg height="20" width="100">
		  <circle class="circlelist" cx="10" cy="10" r="8" stroke="#000099" stroke-width="3" fill="lightblue" />
          <circle class="circlelist" cx="30" cy="10" r="8" stroke="#006600" stroke-width="3" fill="lightgreen" />
          <circle class="circlelist" cx="50" cy="10" r="8" stroke="#990000" stroke-width="3" fill="tomato" />
          <circle class="circlelist" cx="70" cy="10" r="8" stroke="#999900" stroke-width="3" fill="yellow" />
          <circle class="circlelist" cx="90" cy="10" r="8" stroke="#404040" stroke-width="3" fill="orange" />
		</svg>
		<script>
		  d_circles = document.getElementsByClassName("circlelist")
		  for (var i=0; i < 5; i+=1) {
			  d_circles[i].fill = color_fill[i]
			  d_circles[i].stroke = color_stroke[i];
		  }
		  </script>
      </p>

      <p>
        A few rep locations have already been set up, but
        you can add more by clicking the screen.
      </p>
	  
	  
	  		<aside style="width:150px">
		<div id="options" style="display:none">
		<form>
		<fieldset>
		<legend>Output:</legend>
		<input id="calcVoterCom" type="checkbox" checked="true"> Calculate Voter Communities <br />
		</fieldset>
		<fieldset>
		<legend>Keeps:</legend>
		<input type="range" min = 500000 max = 3000000 step = 500000 id="cost" value="1000000" oninput="outputUpdate(value)" class="slider-width" style="width:100px"> <br />
		<output for=cost id=costDisplay>1.0</output> Multiplier <br />
		<input class="op" type="radio" name="keeps" checked="true">	Seats Plus Zero <br />
		<input class="op" type="radio" name="keeps">	Seats Plus Half <br />
		<input class="op" type="radio" name="keeps">	Seats Plus One <br />
		</fieldset>
		<fieldset>
		<legend>Ballot:</legend>
		<input class="op"  checked="true"  type="checkbox">	Normalize <br />
		<input class="op" checked="true"  type="radio" name="ballots"> 	1 / Distance<br />
		<input class="op" type="radio" name="ballots">  Linear <br />
		<input class="op" type="radio" name="ballots">  Exponential <br />
		<input class="op" type="radio" name="ballots"> 	Threshold (todo) <br />
		</fieldset>
		<fieldset>
		<legend>Similarity Measure:</legend>
		<input class="op" type="radio" name="similarity" checked="true"> Jaccard<br />
		<input class="op" type="radio" name="similarity"> Both Out Of One<br />
		<input class="op" type="radio" name="similarity"> One From Either<br />
		<input class="op" type="radio" name="similarity"> Simultaneous<br />
		<input class="op" type="radio" name="similarity"> integrateKeeps<br />
		<input class="op" type="radio" name="similarity"> Cosine<br />
		<input class="op" type="radio" name="similarity"> L1<br />
		<input class="op" type="radio" name="similarity"> multiplySupport<br />
		</fieldset>
		<fieldset>
		<legend>Computation:</legend>
		<input class="op" checked="true" type="radio" name="compute"> Our Binary Quadratic Problem as described above. <br />
		<input class="op" type="radio" name="compute"> STV <br />
		<input class="op" type="radio" name="compute"> Meeks STV <br />
		<input class="op" type="radio" name="compute"> RRV  <br />
		<input class="op" type="radio" name="compute" id="openstv"> OpenSTV (todo)
		<select id="stvtype" name="stvtype" onclick="selectOpenstv()">
			<option value="Approval">Approval</option>
			<option value="Borda">Borda</option>
			<option value="Bucklin">Bucklin</option>
			<option value="CambridgeSTV">CambridgeSTV</option>
			<option value="Condorcet">Condorcet</option>
			<option value="Coombs">Coombs</option>
			<option value="ERS97STV">ERS97STV</option>
			<option value="FTSTV">FTSTV</option>
			<option value="GPCA2000STV">GPCA2000STV</option>
			<option value="IRV">IRV</option>
			<option value="MeekQXSTV">MeekQXSTV</option>
			<option value="MeekSTV">MeekSTV</option>
			<option value="NIrelandSTV">NIrelandSTV</option>
			<option value="QPQ">QPQ</option>
			<option value="RTSTV">RTSTV</option>
			<option value="SNTV">SNTV</option>
			<option value="ScottishSTV">ScottishSTV</option>
			<option value="SuppVote">SuppVote</option>
			<option value="WarrenQXSTV">WarrenQXSTV</option>
			<option value="WarrenSTV">WarrenSTV</option>
		</select> <br />
		<input class="op" type="radio" name="compute"> Plurality Multiwinner <br />
		<input class="op" type="radio" name="compute"> Schulze STV (bug)<br />
		<input class="op" type="radio" name="compute"> Clustering like original<br />
		<input class="op" type="radio" name="compute"> A new formulation (working on it) 
	    </fieldset>
		<fieldset>
		<legend>Map:</legend>
		<input type="range" min = .1 max = 1 step = .1 id="zoom_id" value="1" oninput="updateZoom(value)" class="slider-width" style="width:60px">Zoom<br />
		<input type="range" min = -1 max = 1 step = .1 id="xshift_id" value="0" oninput="updateXshift(value)" class="slider-width" style="width:60px">X<br />
		<input type="range" min = -1 max = 1 step = .1 id="yshift_id" value="0" oninput="updateYshift(value)" class="slider-width" style="width:60px">Y<br />
		</fieldset>
		</form>
		</div>
	    </aside>
	  
      <div id="demoarea">
      </div>
	  
      <div id="spinnerdiv">
      </div>
	  
	  <div style="float:left;width:800px;">
	  
	  
	  
	  <div style="float: left; width: 100%;">
	  <p>
      <button class="pure-button" onclick="compute()">Compute Winners</button>
      <button onclick="restart()">Restart</button>
	  <button class="pure-button" onclick="toggle_options()">Beast Mode</button>
	  <button class="pure-button" onclick="toggle_div()">Gurobi Log</button>
	  &nbsp; &nbsp; &nbsp; &nbsp;
	  <input type="range" min = 1 max = 20 step = 1 id="numberOfWinners" value="5" oninput="numberOfWinnersUpdate(value)" class="slider-width" style="width:200px">
	  <output for=numberOfWinners id=numberOfWinnersDisplay>5</output> Winners <br />

      </p>
	  </div>
	  
	  <div id="divtableshow" style="width: 50%; float: right; ">
	  <p>
	  Election Results:
	  </p>
	  <canvas id="tableshow" width="350" height="300"></canvas>
	  </div>
	  
	  <div id="divvotertableshow" style="width: 49%; float: right;">
	  <p>
	  Voter Communities:
	  </p>
	  <canvas id="votertableshow" width="350" height="350"></canvas>
	  </div>
	  
	  </div>
	  
          <script>
			var cost;
			var numberOfWinners;
			function outputUpdate(value) {
			  document.querySelector('#costDisplay').value = value/1000000;
			}
			function numberOfWinnersUpdate(value) {
			  document.querySelector('#numberOfWinnersDisplay').value = value;
			}
			function updateZoom(value) {
			  zoomit = value;
			  draw_map();
			}
			function updateXshift(value) {
			  xshift = value;
			  draw_map();
			}
			function updateYshift(value) {
			  yshift = value;
			  draw_map();
			}
			function selectOpenstv() {
			document.querySelector('#openstv').checked = true;
			}
		  </script>  
		  
      <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
      <script>
        function toggle_div() {
          var logfile = d3.select('#logfile');
          if (logfile.style("display") === "none") {
            logfile.style("display", "block");
          } else {
            logfile.style("display", "none");
          }

        }
		function toggle_options() {
          var optionsdiv = d3.select('#options');
		  var tableshowdiv = d3.select('#divtableshow');
		  var votertableshowdiv = d3.select('#divvotertableshow');
		  optionsdiv.style("display", "block");
		  tableshowdiv.style("display", "block");
		  votertableshowdiv.style("display", "block");
		  //actually we don't want to cause confusion.  If you activate beast mode, you can't go back.
          // if (optionsdiv.style("display") === "none") {
          //   optionsdiv.style("display", "block");
          // } else {
          //   optionsdiv.style("display", "none"); 
          // }

        }
      </script>
	  
      <examplecode id=logfile  style="float:left; width: 100%;">
      </examplecode>

      
    </div>
	<div style="float:left">
	<p>
        <button id="morebutton" class="pure-button" onclick="toggle_readmore()">Read More</button>
      </p>


      <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
      <script>
		function toggle_readmore() {
          var readmorediv = d3.select('#readmore');
          if (readmorediv.style("display") === "none") {
            readmorediv.style("display", "block");
          } else {
            readmorediv.style("display", "none");
          }
        }
      </script>
	</div>
	<div id="readmore" style="display:none; float:left">
	<p>
		The output is worth explaining.  The similarity measures can be put into a table so that more similar pairs of reps are indicated by light grey and distant pairs are dark grey.  Similarity is a measure from 0 (dark) to 1 (light).  Each pair is a square on the table (technically 2 squares).  Also, to the left of the election results table is a bar chart showing the vote totals for each rep.  The scale at the bottom has tick marks that indicate 1 keep (votes/seats).  The great thing about this kind of table of election results is that it shows communities of similar reps.  Each community of reps looks like a big bright square along the diagonal.  You can really see this effect if you add about 20 reps.  Even better is to use the 200 voters to show communities.  This kind of data would not be available in an election.  It is kind of cheating to know where the voters are.  You can see how big each community of voters is and which reps (colors) are serving each community.
	</p>
     <p>
		There is also a beast mode where you can see different computations.  STV is included.  <a href="https://www.opavote.com/methods/single-transferable-vote">OpenSTV's implementations</a> of several voting methods are there.  Another method is a clustering method where the total distance between voters and reps is minimized.  This is similar to the project that this project was forked from.  Also, I am working on a new optimization based on a form of reweighted range voting (as of now it takes too long, maybe about a minute to run).  There is normal reweighted range voting (RRV) as an option as well.  In addition to computations, there are also different ballot types, an option for disabling normalization, an option for adding a +1 to the seats, different similarity measures, etc. .  Also, you can change the amount of keeps to test how proportional a different level would be.
      </p>
	  <p style="font-size:8px">
        <a name="geolytix">Location data:</a>
        <a href="http://geolytix.co.uk/downloads/OpenSupermarkets.zip">Supermarket
        locations &copy; GeoLytix</a> copyright and database right 2014.
      </p>

      
      <div class="example_section" id="thoughts">
      <h2>Here's my thoughts.</h2>
      <p>
      It turns out I finally invented a good voting system.  So, how did I come up with it?  Well, I had thought of it before but couldn't work out the math.  It is the same as STV because it has a quota.  It is different than STV because it searches for the best combination of reps that would maximize voter support for the winners.  
        </p>
        <p>
        I didn't think it would work.  I thought I was over-penalizing.  However, I realized that I could set the quota so that it optimized the number of reps coming from a voter base.  The optimization is for proportionality.  I tried to use the same quota as STV's droop quota: number of voters over number-of-seats-plus-1.  
        </p>
        <p>
        Some things to change:  I'm not sure exactly what the quota should be because I'm not sure how they'll actually vote.  Right now, I have put them as all voting depending on their distance from a rep.  Maybe I would choose a different function.  Maybe voters would want to maximize the range of their vote.  Maybe they would have just two levels of support, high and low, and they would change their threshold depending on who is running and who other people are voting for.
        </p>
        <p>
        Things to do.
        </p>
        <p>
          <ul><li>compare to clustering (done)
        </li><li>normalize votes (done)
        </li><li>try exponential choice function (done)
        </li><li>try linear choice function (done)
        </li><li>try threshold choice function
        </li><li>add STV comparison (done)
        </li><li>add CPO-STV comparison
        </li><li>far future: put this into ncase's better ballot.
        </li><li>far future: yee diagram in background
        </li><li>explanation: what is the incentive of the voters to vote honestly?  Couldn't they find a way to avoid penalties by only supporting one rep?  Isn't that strategy also applicable to STV?
        </li></ul>
          </p>
        <p>
        So basically what I was thinking was to write out a matrix of the penalties.  Then show that the penalties lead to a correct number of representatives for this voter-base.  
        </p>
        <p>
        In clustering, voters dont have influence outside their cluster.  In this penalty system, they can have negative influence if they get too many representatives... maybe.. but they would never get too many
        </p>
        <p>
        I need to motivate this with the idea of search.  There is depth-first, which is greedy and assigns the single reps with the highest vote counts first.  Standard STV does this kind of depth-first search.  In STV, if more people like a rep than the quota, then those people can get their second choices as well.  This is like at-large voting, except after your rep gets a seat, part of your vote stays with them and only part of it gets to go to a second rep.  This kind of division of the vote can be accomplished by subtracting the "kept" votes from the total vote count.  This avoids overcounting.
        </p>
        <p>
        The algorithm searches through all the possible combinations of seat assignments for the reps.  It tries to maximize the number of voters who support the winning reps.  It avoids double-counting in the same way as STV.  It keeps some of the votes for similar reps.
        </p>
        <p>
        Basically, this cosine similarity is a measure of an angle.  It is not a typical angle.  It is not in 2 dimensions.  It is actually in many more dimensions, as many dimensions as there are reps.  Still, the same idea holds in 2 dimensions that the more aligned 2 reps are, the bigger the cosine similarity.  It ranges from 0 for reps that have nothing in common to 1 for identical "clone" reps.
        </p>
        <p>
        This information gets put into the problem definition table by simply multiplying each entry by cosine similarity.  Even the diagonals work! It's actually pretty easy.
        </p>
        <p>

        Now we just tell the optimization software to pick the 5 best rows and columns that have the biggest sum.  Those are the best winners.
        </p>
        <p>
        You can see that some areas have 2 reps close together.  Sometimes a cluster of voters is big enough and supportive enough (close to the reps), to elect 2 reps.
        </p>
        <p>
        Of course there are details I left out.
        </p>
        <p>
        These are just my thoughts.
        </p>
		<p>
		So What?
		</p>
		<p>
		Distance is good, 2D is great.  Let's think about the 3rd Dimension.  What would it be?  It doesn't have to be distance.  It can be political affiliation.  Now, the 4th.  It can be a particular issue.  And we can have as many dimensions as their are issues  and there won't be any more wedge issues that keep you stuck in a 1-dimensional partisan left-right line.
		</p>
		</div>
	  
	  
    </div>
    </div>

    <div style="min-height:100px"></div>

<!--[if gt IE 8]><!--><script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script><!--<![endif]-->
<script src="jquery.nav.js"></script>
<script>
  $(document).ready(function() {
  console.log('calling onePageNav');
  $('#nav').onePageNav({scrollOffset:120});
  });
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/spin.js/1.2.7/spin.min.js"></script>
<script>

// Hide Log File intially
d3.select('#logfile').style("display", "none");

//Width and height
var width = 800;
var height = 500;
var padding = 30;
var miles_per_px = 0.19;
var price_per_px = 3*miles_per_px;
var alpha = 5*365*price_per_px; // Consider the cost over 5 years
alpha = alpha * 1754385.964912 * 0.000548 // let's change alpha for "keep"
alpha = 1000100
alpha = 1000000
var spinner;

var svg = d3.select("#demoarea")
              .append("svg")
              .attr("width", width)
              .attr("height", height);

// Potential sites for facilities
var sites = [[.3*width, .8*height], [.4*width, .3*height], [516.40625, 380.34375],
             [486.40625, 55.34375], [766.40625, 179.34375], [728.40625, 439.34375]];

var cost = parseFloat(document.getElementById("cost").value)/alpha;

var charge = d3.range(sites.length).map(function(d) { return cost; });


// G object for background
var backgroundG;

// G object for map
var mapG;

// G object for animations
var animationG;

// G object for sites
var sitesG;

// G object for points
var circleG;

// G object for voronoi
var pathG;

// G object for facilities
var facilitiesG;

// G object for location names
var locationG;

// G object for clickable areas
var clickableG;

// G object for spinner
var spinnerG;

var zoomit = 1;
var xshift = 0;
var yshift = 0;
var projection;
var path;
var vertices;

var places;
var counties;

var stateVoterCom = "initial";
var voterCom;
var vorder;
var stateInitialMap = 1;

function draw_map() {

if (stateVoterCom == "old still good" | stateVoterCom == "new map") {
	stateVoterCom = "new map";
	stateInitialMap = 0;
} else if (stateVoterCom == "initial") {
	stateVoterCom = "new map";
}
    
// G object for background
backgroundG = svg.append("g");

// G object for map
mapG = svg.append("g");

// G object for animations
animationG = svg.append("g");

// G object for sites
sitesG = svg.append("g");

// G object for points
circleG = svg.append("g");

// G object for voronoi
pathG = svg.append("g");

// G object for facilities
facilitiesG = svg.append("g");

// G object for location names
locationG = svg.append("g");

// G object for clickable areas
clickableG = svg.append("g");

// G object for spinner
spinnerG = svg.append("g").attr("id", "spinid");


backgroundG.append("rect")
           .attr("x", 0).attr("y", 0)
           .attr("width", width).attr("height", height)
           .attr("fill", "#A3CCFF"); // "#66B2FF"
		   

sitesG.selectAll("circle")
       .data(sites)
       .enter()
       .append("circle")
       .attr("cx", function(d) { return d[0]; })
       .attr("cy", function(d) { return d[1]; })
       .attr("class", "site")
       .attr("r", 5);

var mapColors = [];
var maxRed = 247, minRed = 116;
var maxGreen = 252, minGreen = 196;
var maxBlue = 245, minBlue = 118;
var maxRed = 247, minRed = 116+100;
var maxGreen = 252, minGreen = 196+50;
var maxBlue = 245, minBlue = 118+100;
var maxRed = 247, minRed = 203;
var maxGreen = 252, minGreen = 230;
var maxBlue = 245, minBlue = 163;
var numColors = 40;
for (var i = 0; i < numColors; i++) {
  var red = String( Math.round( minRed + (maxRed - minRed)*i/numColors ) );
  var green = String( Math.round( minGreen + (maxGreen - minGreen)*i/numColors) );
  var blue = String( Math.round( minBlue + (maxBlue - minBlue)*i/numColors ) );
  mapColors.push( "rgb(" + red + "," + green + "," + blue + ")");
}


	projection = d3.geo.albers()
		.center([.2, 53.6 + yshift*3])
		.rotate([2.4 + xshift* -3, 0])
		.parallels([50, 60])
		.scale(1200 * 20 * zoomit)
		.translate([width / 2 , height / 2]);
	path = d3.geo.path()
		.projection(projection);

	d3.json("UKwithCounties.json", function(error, uk) {
	  d3.json("supermarket.json", function(supermarket) {
		vertices = [];
		// Set up map of UK
		places = topojson.feature(uk, uk.objects.placesUK);
		counties = topojson.feature(uk, uk.objects.ukcounties).features;

		mapG.selectAll("path")
			.data(counties)
			.enter()
			.append("path")
			.attr("d", path)
			.attr("fill", function(d,i) { return mapColors[i % 10 + 10]; })
			//.attr("fill", function(d,i) { return mapColors[i % 9]; })
			//.attr("fill", function(d,i) { return mapColors[i%3+7]; })
			//.attr("fill","#CBE6A3")
			//.attr("stroke", "rgb(150,150,150)")
			;

		clickableG.selectAll("path")
			.data(counties)
			.enter()
			.append("path")
			.attr("d", path)
			.attr("opacity", 0)
			.on("mousedown", addPoint);

		locationG.append("path")
				 //.datum(places)
				 .attr("d", path)
				 .attr("class", "place");

		locationG.selectAll(".place-label")
				.data(places.features)
				.enter().append("text")
				.attr("class", "place-label")
				.attr("transform", function(d) { return "translate(" + projection(d.geometry.coordinates) + ")"; })
				.attr("x", function(d) { return d.geometry.coordinates[0] > -1 ? 6 : -6; })
				.attr("dy", ".35em")
				.style("text-anchor", function(d) { return d.geometry.coordinates[0] > -1 ? "start" : "end"; })
				.text(function(d) { return d.properties.name; })
				.attr("font-family", "Helvetica Neue")
				.attr("font-size", 15)
				.attr("font-weight", 400);

		// Set up supermarket locations
		// Add locations to vertices array
		circleG.selectAll("circle")
			   .data(supermarket)
			   .enter()
			   .append("circle")
			   .filter(function(d) {
				  var loc = projection([d.LongWGS84, d.LatWGS84]);
				  return ( loc[0] >= 0 && loc[0] <= width && loc[1] >= 0 && loc[1] <= height);})
			   .attr("cx", function (d) { var loc = projection([d.LongWGS84, d.LatWGS84]);
										  vertices.push([parseFloat(loc[0]), parseFloat(loc[1])]);
										  return loc[0]; })
			   .attr("cy", function (d) { var loc = projection([d.LongWGS84, d.LatWGS84]);
										  return loc[1]; })
			   .attr("r", 2)
			   .attr("class", "client");

		console.log('number of vertices', vertices.length);
	  });
	});
	
	if (zoomit != 1 || xshift !=0 || yshift !=0) restart(); // really I'd like to keep some initial points but it wasn't working.
}

draw_map();

function addPoint() {
  facilitiesG.selectAll("circle").remove("circle");
  animationG.selectAll("circle").remove("circle");
  pathG.selectAll("line").remove("line");

  var point = d3.mouse(this);
  console.log('point', point);
  sites.push(point);
  sitesG.append("circle")
         .attr("cx", point[0])
         .attr("cy", point[1])
         .attr("class", "site")
         .attr("r", 5);
  charge.push(cost);

  // Add animation
  animationG.selectAll("circle").remove("circle");
  var anim = animationG.append("circle")
                        .attr("cx", point[0])
                        .attr("cy", point[1])
                        .attr("r", 0)
                        .attr("fill", "black");

  anim.style("opacity", .5)
      .transition()
      .style("opacity", 0)
      .attr("r", 20)
      .duration(200)
      .ease("out");
}

function compute() {

  if (sites.length < 1) {
    alert("Add reps!");
    return;
  }

  facilitiesG.selectAll("circle").remove("circle");
  animationG.selectAll("circle").remove("circle");
  pathG.selectAll("line").remove("line");

  // Show loading screen
  spinnerG.append("rect")
          .attr("x", 0).attr("y", 0)
          .attr("width", width).attr("height", height)
          .attr("fill", "white")
          .attr("opacity", .5);

  spinnerG.append("text")
          .attr("x", width/2)
          .attr("y", .4*height)
          .attr("font-size", 25)
          .attr("font-family", "Helvetica Neue")
          .attr("font-weight", 400)
          .attr("text-anchor", "middle")
          .text("Computing...");

  var target = document.getElementById('demoarea');
  spinner = new Spinner({left: '375%'}).spin(target);

  // options
  cost = parseFloat(document.getElementById("cost").value)/alpha;
  numberOfWinners = parseFloat(document.getElementById("numberOfWinners").value);
  stvtype = document.getElementById("stvtype").value;
  calcVoterCom = document.getElementById("calcVoterCom").checked;
  charge = [];
  charge.push(numberOfWinners);
  charge.push(cost);
  charge.push(stvtype);
  
  // option "calculate voter community"
  if (calcVoterCom+0 == 1) {
	if (stateVoterCom == "old still good"){
		charge.push(0);
	} else { // e.g. "new map" or "option not selected"
		charge.push(1); 
		stateVoterCom = "getting new";
	}
  } else {
	charge.push(0);
	if (stateVoterCom == "new map"){
		stateVoterCom = "option not selected"
	}
  }
  charge.push(stateInitialMap)
  
  var ops = document.getElementsByClassName('op');
  for(var i = 0; i < ops.length; i++){
	charge.push( 0 + ops[i].checked);
  }
  
  d3.json('facility.py')
    .header('Content-Type', 'application/json')
    .post(JSON.stringify({'clients': vertices,
                          'facilities': sites,
                          'charge': charge}), serverResponse);
}


//Function to convert hex format to a rgb color.
function hexToRgb(hex) {
	var result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
	return result ? {
		r: parseInt(result[1], 16),
		g: parseInt(result[2], 16),
		b: parseInt(result[3], 16)
	} : null;
}

function serverResponse(error, data) {
  console.log('serverResponse');
  console.log('data', data);

  // Remove loading screen
  spinnerG.selectAll("rect").remove("rect");
  spinnerG.selectAll("text").remove("text");
  spinner.stop();

  if (!error) {
      if ('solution' in data) {
          // Import solution and put it into correct format
          var solution = data['solution'];
          if (solution[0] === "error") {
            alert("100 second solve time limit exceeded. Reduce the number of reps.");
            return;
          }
          var solution1 = solution[0]; // Facilities to open
          var solution2 = solution[1]; // Edges to draw
          var logMsg = solution[2]; // Log message to display

          d3.select('#logfile').html(logMsg);

          var facilities = [];

          for (var i = 0; i < solution1.length; i++) {
            facilities.push(sites[solution1[i]]);
          }

          facilitiesG.selectAll("circle").remove("circle");
          animationG.selectAll("circle").remove("circle");

          var faci = facilitiesG.selectAll("circle")
                     .data(facilities)
                     .enter()
                     .append("circle")
                     .attr("cx", function(d) { return d[0]; })
                     .attr("cy", function(d) { return d[1]; })
					 .attr("class","repclass")
					 .attr("fill", function(d, i) { return color_fill[i % color_fill.length]; })
					 .attr("stroke", function(d, i) { return color_stroke[i % color_stroke.length]; })
                     .attr("r",60)
                     .attr("stroke-width", 2);

          var anim = animationG.selectAll("circle")
                     .data(facilities)
                     .enter()
                     .append("circle")
                     .attr("cx", function(d) { return d[0]; })
                     .attr("cy", function(d) { return d[1]; })
					 .attr("class","repclass")
					 .attr("fill", function(d, i) { return color_fill[i % color_fill.length]; })
					 .attr("stroke", function(d, i) { return color_stroke[i % color_stroke.length]; })
                     .attr("r",0)
                     .attr("stroke-width", 0);

          faci.style("opacity", 0)
              .style("stroke-opacity", 0)
              .transition()
              .style("opacity", 1)
              .style("stroke-opacity", 1)
              .attr("r", 6)
              .duration(500)
              .delay(function(d, i) { return i*100 });

          anim.style("opacity", .5)
              .style("stroke-opacity", .5)
              .transition()
              .style("opacity", 0)
              .style("stroke-opacity", 0)
              .attr("r", 30)
              .duration(500)
              .ease("out")
              .delay(function(d, i) { return i*100 + 300});

          pathG.selectAll("circle").remove("circle");

          var connections = pathG.selectAll("circle")
                                 .data(solution2)
                                 .enter()
								 .append("circle")
								 .attr("r", 2)
								 .attr("cx", function(d) { var loc = vertices[d[0]]; return loc[0]; })
                                 .attr("cy", function(d) { var loc = vertices[d[0]]; return loc[1]; })
								 .attr("class","voterclass")
								 .attr("fill", function(d, i) { return color_fill[solution1.indexOf(d[1]) % color_fill.length]; })
								 .attr("stroke", function(d, i) { return color_stroke[solution1.indexOf(d[1]) % color_stroke.length]; })
								 .attr("opacity", 0);

          connections.transition()
                     .attr("opacity", .6)
                     .duration(500)
                     .delay(0);
		  circleG.transition()
                     .attr("opacity", 0)
                     .duration(500)
                     .delay(0);
		  
		  var c=document.getElementById("tableshow");
		  var ctx=c.getContext("2d");
		  ctx.clearRect(0, 0, c.width, c.height);
		  
		  var c3=document.getElementById("votertableshow");
		  var ctx3=c3.getContext("2d");
		  ctx3.clearRect(0, 0, c3.width, c3.height);
				
		  if (solution.length > 3) {
		  
			  // Show adjacency matrix
			  
			  if (1) {
				var s_table = solution[3];
			  } else {
				var s_table = solution[6];
			  }
			  var w_winnersb = solution[4];
			  var ld = w_winnersb.length;
				var imgData=ctx.createImageData(ld,ld);
				for (var i=0;i<ld;i+=1) {
					for (var j=0;j<ld;j+=1) {
					  ind = (i*ld+j)*4
					  val = s_table[i][j];
					  if (0) val = 1-val;
					  w_won = i==j && w_winnersb[i] == 1 && w_winnersb[j] == 1 ;
					  if (w_won) val = 1;
					  imgData.data[ind+0]=255*val;
					  imgData.data[ind+1]=255*val;
					  imgData.data[ind+2]=255*val;
					  imgData.data[ind+3]=255;
					  if (w_won) imgData.data[ind+1] *= .6;
					}
				}
				
				
				function scaleImageData(imageData, scale) {
				  var scaled = ctx.createImageData(imageData.width * scale, imageData.height * scale);
				  for(var row = 0; row < imageData.height; row++) {
					for(var col = 0; col < imageData.width; col++) {
					  var sourcePixel = [
						imageData.data[(row * imageData.width + col) * 4 + 0],
						imageData.data[(row * imageData.width + col) * 4 + 1],
						imageData.data[(row * imageData.width + col) * 4 + 2],
						imageData.data[(row * imageData.width + col) * 4 + 3]
					  ];
					  for(var y = 0; y < scale; y++) {
						var destRow = row * scale + y;
						for(var x = 0; x < scale; x++) {
						  var destCol = col * scale + x;
						  for(var i = 0; i < 4; i++) {
							scaled.data[(destRow * scaled.width + destCol) * 4 + i] =
							  sourcePixel[i];
						  }
						}
					  }
					}
				  }
				  return scaled;
				}
				
				
				a_border=10;
				a_width = c.width-50-10-2*a_border;
				a_height = c.height-7;
				//a_scale = Math.min(10,Math.floor(a_width/ld))
				a_scale = Math.floor(Math.min(a_width,a_height)/ld)
				//a_scale = Math.round(a_width/(ld));
				ctx.putImageData(scaleImageData(imgData,a_scale),a_border+50+10,a_border);
				
				// Highlight the winners
				
				var a_id = solution[8];
				var a_order = solution[7];
							
				for (var i=0;i<ld;i+=1) {
					for (var j=0;j<ld;j+=1) {
					  w_won = w_winnersb[i] == 1 && w_winnersb[j] == 1 ;
					  if (w_won) {
						i_color = color_fill[a_id[i] % color_fill.length]
						j_color = color_fill[a_id[j] % color_fill.length]
						if (i==j) {
							x = a_border+50+10 + (i)*a_scale
							y = a_border+ (j)*a_scale
							ctx.fillStyle = i_color;
							ctx.fillRect( x, y, a_scale,a_scale );
							ctx.fillRect( 10-a_scale+1, y+1, a_scale-2,a_scale-2 );
						} else {
							x = a_border+50+10 + (i+1/2)*a_scale
							y = a_border+ (j+1/2)*a_scale
							if (0) {
								ctx.fillStyle = "rgb(255,153,255)";
								ctx.fillRect( x-1, y-1, 3, 3 );
							} else {
								ctx.fillStyle = (i<j) ? i_color : j_color;
								ctx.fillRect( x-3, y-1, 3, 3 );
								ctx.fillStyle = (i>j) ? i_color : j_color;
								ctx.fillRect( x, y-1, 3, 3 );
							}
						}
					  }
					}
				}
				
				// Bar Graph
				
				var t_tallys = solution[5];
				var t_max = Math.max(...t_tallys);
				var t_max_inv = 1/t_max;
				
				var imgData2=ctx.createImageData(50,ld*a_scale);
				for (var i=0;i<ld;i+=1) {
					for (var r=0;r<a_scale;r+=1) {
						for (var y=0;y<50;y+=1) {
							ind = 4*(y + 50*(r + a_scale*i));
							if (y<50*t_tallys[i]*t_max_inv) {
								var f = .6
								if (w_winnersb[i]) f = .7;
								imgData2.data[ind+0]=255*f;
								imgData2.data[ind+1]=255*f;
								imgData2.data[ind+2]=255*f;
								imgData2.data[ind+3]=255;
							} else {
								imgData2.data[ind+0]=255;
								imgData2.data[ind+1]=255;
								imgData2.data[ind+2]=255;
								imgData2.data[ind+3]=255;
							}
						}
					}
				}
				ctx.putImageData(imgData2,a_border,a_border);
				
				// Scale
				var keep = solution[9];
				var tick = 50*keep/t_max
				ctx.fillStyle = "gray";
				y_axis = a_border + a_scale*ld + 3;
				ctx.fillRect( a_border, y_axis, 50, 1 );
				for (var i = 0; i < 50; i += tick) ctx.fillRect( a_border+i, y_axis+1, 1, 3 );
				
				
				// Show adjacency matrix for voters only
				if (stateVoterCom == "option not selected") {
					dummy=1;// don't need to do anything
				} else {
					if (stateVoterCom == "old still good") {
						// voterCom from last time
						votercolor = solution[13];  // new colors
						votercomcolor = vorder.map(function (i) { return votercolor[i] }); // vorder from last time
						var v_id = votercomcolor;
					} else { // if (stateVoterCom == "getting new"){ //never going to be "need new" since we pressed calculate
					    // if (solution[10]) { // double check
						stateVoterCom = "old still good";
						// voterCom from last time
						voterCom = solution[11];
						votercomcolor = solution[12];
						var v_id = votercomcolor;
						vorder = solution[14];
					} 
					var ld3 = voterCom.length;
					var imgData3=ctx3.createImageData(ld3+10,ld3+10);
					
					for (var j=10;j<ld3+10;j+=1) {
						g_color = hexToRgb(color_fill[v_id[j-10] % color_fill.length])
						for (var i=0;i<10;i+=1) {
							ind = (i*(ld3+10)+j)*4
							imgData3.data[ind+0]=g_color.r;
							imgData3.data[ind+1]=g_color.g;
							imgData3.data[ind+2]=g_color.b;
							imgData3.data[ind+3]=255;
						}
					}
					
					for (var i=10;i<ld3+10;i+=1) {
						g_color = hexToRgb(color_fill[v_id[i-10] % color_fill.length])
						for (var j=0;j<10;j+=1) {
							ind = (i*(ld3+10)+j)*4
							imgData3.data[ind+0]=g_color.r;
							imgData3.data[ind+1]=g_color.g;
							imgData3.data[ind+2]=g_color.b;
							imgData3.data[ind+3]=255;
						}
						for (var j=10;j<ld3+10;j+=1) {
							ind = (i*(ld3+10)+j)*4
							if (i==j) {
								h_color = hexToRgb(color_fill[v_id[i-10] % color_fill.length])
								imgData3.data[ind+0]=h_color.r;
								imgData3.data[ind+1]=h_color.g;
								imgData3.data[ind+2]=h_color.b;
								imgData3.data[ind+3]=255;
							} else {
							val = voterCom[i-10][j-10];
							if (0) val = 1-val;
								imgData3.data[ind+0]=255*val;
								imgData3.data[ind+1]=255*val;
								imgData3.data[ind+2]=255*val;
								imgData3.data[ind+3]=255;
							}
						}
					}
					b_width = Math.min(c3.width,c3.height) - 10;
					b_scale = Math.max(1,Math.floor(b_width/ld3));
					ctx3.putImageData(scaleImageData(imgData3,b_scale),0,0);
				}
			}
        }
      }
}


function restart() {
  sitesG.selectAll("circle").remove("circle");
  facilitiesG.selectAll("circle").remove("circle");
  animationG.selectAll("circle").remove("circle");
  pathG.selectAll("circle").attr("class", "client").attr("r",2);
  sites = [];
}

</script>


