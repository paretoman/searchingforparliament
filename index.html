<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1">
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
                      tex2jax: {inlineMath: [['$', '$'], ['\\(','\\)']]},
                      TeX: { equationNumbers: {autoNumber: "AMS"} },
                      "HTML-CSS": { showMathMenu: false,
                                    scale: 90 }
                     });
</script>
<link rel="stylesheet" href="base.css">
<style>
a:hover.screenshot {
  opacity: .7;
}

.site {
  fill: white;
  stroke: black;
  stroke-width: 1;
}

.client {
  fill: black;
  opacity: .5;
}

.c0 { fill: blue; stroke: #000099 }
.c1 { fill: green; stroke: #006600 }
.c2 { fill: red; stroke: #990000}
.c3 { fill: yellow; stroke: #999900 }
.c4 { fill: gray; stroke: #404040 }

.v0 { fill: blue; stroke: #000099 }
.v1 { fill: green; stroke: #006600 }
.v2 { fill: red; stroke: #990000}
.v3 { fill: yellow; stroke: #999900 }
.v4 { fill: gray; stroke: #404040 }

.place,
.place-label {
  fill: black;
  opacity: 1;
  stroke: none;
}

</style>
<body>
<ul id="nav2">
    <li class="current"><a href="#intro">Intro</a></li>
    <li><a href="#problem">Problem</a></li>
    <li><a href="#model">Model</a></li>
    <li><a href="#implementation">Implementation</a></li>
    <li><a href="#demo">Live Demo</a></li>
    <li><a href="#try">How to set up.</a></li>
  </ul>
  <div id="example_container">
    <div class="example_section" id="intro">
      <h1>Searching for Parliament</h1>
        <subtitle>(the computer science kind of search)</subtitle>
    </div>
    <p>
      Selecting a group of people to represent a nation is an example of what computer science calls an assignment search problem.  Which candidates are the most representative of the voters?
    </p>

    <p>
      We'll construct a mathematical model of the assignment search problem, implement this model in the Python programming language with an optimization package called Gurobi, and compute and visualize an optimal solution.
    </p>

    <p>
      The implementation of the model and the structure of this explanation is forked from the work of Emilien Dupont (on <a href="https://github.com/EmilienDupont/facilityLocation">github</a> and hosted as <a href="http://examples.gurobi.com/facility-location/"> a featured example on Gurobi's website</a>)
    </p>

    <h3>
      Click the screenshot to skip directly to the Live Demo!
    </h3>
    <p>
      <a href="#demo" class="screenshot">
        <img src="screenshot.png" alt="Live Demo" style="width: 100%; vertical-align: middle;">
      </a>
    </p>


    <div class="example_section" id="problem">
      <h2><a href="#problem" name="problem">Problem Description</a></h2>

    <div style="float:right;">
      <a href="https://en.wikipedia.org">
        <img src="Sir_Gerald_Kaufman.jpg" alt="Sir_Gerald_Kaufman" style="width:200px;">
      </a>
    </div>

    <p>Northern England gets rid of district boundaries because there was too much debate about where the boundaries should go.  It wants to elect 4 reps (representatives).  And it wants to space them out instead of having them all from the middle.  It wants regional interests to be represented and it doesn't want all the seats to be taken by people from the same neighborhood in the middle of Northern England.</p>

    <p>Several good potential reps have decided to run, but it remains to decide which of the reps should win.</p>

        <aside> A typical rep.<span style="font-size: 10px"></span>
    </aside>

    <p>Selecting reps from the middle of Northern England would be advantageous as they would have the most votes overall.  However, voters from the middle of Northern England would be overrepresented and voters from the coast would be very far from their from their reps.</p>

    <p>We will find the optimal tradeoff between reps being near all the voters and voters having reps nearby.</p>

    </div>

    <div class="example_section" id="model">
      <h2><a href="#model" name="model">Mathematical Model</a></h2>

      <p>
        Our problem is related to a very famous problem in computer science called the knapsack problem.  It differs in many ways.  It is similar in how it can be solved.  Both are kinds of binary search.  A search problem tries to find a combination of variables that is in some way the best combination.  One way to approach such a problem is the branch and bound method.  Here is a video on the <a href="https://www.coursera.org/learn/discrete-optimization/lecture/66OlO/knapsack-5-relaxation-branch-and-bound">branch and bound method</a> from a fantastic Coursera course in the field of <a href="https://www.coursera.org/learn/discrete-optimization/">discrete optimization</a>.  From this video, just understand that <b>there is a large number of possible choices to make and that they can all be organized in a tree structure</b>.  (The actual algorithm for searching through the tree will be taken care of by Gurobi, and we don't talk about it below.)  We still haven't said what the score is for each choice (or path) in the tree, so let's do that.  Most of the writing below is about that.  Each choice in the tree represents whether a rep wins.  The first split is for the first rep, the second split is for the second rep, etc.
      </p>
        <p> 
        <img src = "./tree.png" />
        </p>
      <p>
          This tree is not for the problem at hand, but our problem is similar because it has the same binary variables $x_i$.
      <p>
        Let us now formulate a mathematical model for our problem.
      </p>
      <p>
        We need to say when we choose a rep.  Let's list all the reps as rep #1, rep #2, rep #3, etc, and let's make variables for each one.  If we choose rep #1, then $x_1=1$ and if we don't choose rep #2, then $x_2=0$.  Basically, $x_j$ is binary.
        \[
        x_j = \left\{\begin{array}{ll}
               1 & \text{if we choose rep #j, }\\
               0 & \mathrm{otherwise.}
              \end{array}\right.
        \]
      </p>
      <p>
        We need to say how close a voter is to a rep.  Let's list all the voters as voter #1, voter #2, etc, and let's make measurements for each voter and rep combination.  If the distance between voter #1 and rep #3 is 100 km, then $d_{13}=100$.  Technically, this is not a variable; it's a constant.
        \[
        d_{ij} = \text{distance between voter i and rep j}
        \]
      </p>

      <p>
        We need to say what a ballot looks like.  We're going to make a simplification of the problem so that we can move forward.  We're going to let the voters give the candidates scores.  This is actually nicer for the voters because they get to say what they think of every rep.  Also, we're going to make every voter use the same scoring scale, and they will base their score entirely on how far away the rep is.  Basically, the inverse of distance.  
        \[
        b_{ij} = \frac{1}{d_{ij}/10 + 1} \text{ (ballot)}
        \]
      </p>
      <p>
        (The 10 is here for normalizing distance.  The extra 1 is here to avoid dividing by 0.  Really, there are many choices for this function, and we may even want to allow voters to vote on different scales because voters would often give the candidate closest to them the highest score possible even if they aren't actually all that close.)
      </p>
      <p>
        We need a way to count the ballots.  The easiest way is to add them together to get the reps' tallies.
        \[
        tally_j = \sum_{i \in Voters} b_{ij} 
        \]
      </p>
        <p>
        <img src="./tally.png" />
        </p> 
      <p>
        If we stop here then we just end up picking the candidates in the middle because they have the highest tallies.
      </p>
      <p>
        We want to avoid overrepresenting the middle voters.  Our solution is to let the winning reps keep a fraction of their voters' ballots.  Basically, these voters have the reps, so the reps get to keep the voters.  Each winning rep keeps the same amount of support.
        \[
        keep = \text{an amount of score. same units as ballots.  same for each winning rep.}
        \]
      </p>
      <p>
        The idea of the rep keeping some ballots is not new.  The election method called Single Transferable Vote (STV) does the same thing.  It is different because it doesn't use scores.  It uses ranking.  Still, it is very similar.  STV calls it a quota.  
        \[
        \text{STV quota} = \frac{voters}{seats + 1}
        \]
        The quota is set as the number of voters divided by the number of seats to fill with reps.  An additional 1 is added to the number of seats because of the iterative nature of STV (a longer explanation is needed).
      </p>
      <p>
        Let's try something like the STV quota.
        \[
        keep = \frac{\sum_{i \in Voters} \max_{j \in Reps} b_{ij}}{seats + 1}
        \]
        Usually, we would use 1 as the maximum score a voter could give.  In our specific problem, we are basing the score on distance, so we need to use a different number.  We add up each voter's max score they gave on their ballot.  Then we divide by the same number of seats as STV.
      </p>
      <p>
          However, there is an issue that is still unsettled.  I have a +1 in the keeps formula because STV has a +1.  However, this might not be needed because there is no iterative step in this problem.
      </p>
      <p>
        There actually is a nice example I will show to say how this STV-style quota selects the correct number of reps for a group of voters.  It also will motivate the next step.
      </p>
      <h3> Mini Example </h3>
      <p>
        Ok, we'll show an example.  We can actually see the method at work.
      </p>
      <p>
        There are 4 seats to fill. There are 20 voters.  For 10 of the voters, they like only 2 reps and give them a score of 1 on their ballots.  So ideally, we would expect those 2 candidates to win.  Let's make a chart to describe the situation:
        \[
        \begin{array}{ll}
        & \text{10: tally for each rep} \\
        & \text{4: amount of tally kept by each rep} \\
        & keeps = \frac{20}{4 + 1} = 4 \\
        & \text{table of reps:}
          \begin{bmatrix} 
                10 & -4  \\
                -4 & 10  \\
            \end{bmatrix}
        \end{array}
        \]
          
        The table describes all the kinds of tally's, the total tallies and the kept tallies. The reps are organized in the rows and the columns.  
          \[
          \text{Row 1 column 1 says rep #1 has a tally of 10 votes in support.  } \\
          \text{Row 1 column 2 says rep #1 keeps 4 from the tally of rep #2.} \\
          \text{Row 2 column 2 says rep #2 has a tally of 10 votes in support.} \\
          \text{Row 2 column 1 says rep #2 keeps 4 from the tally of rep #1.}
          \]
      </p>
      <p>
      Here is a part of the problem statement that took a long time for me to figure out.  In STV, you might think that the kept votes only happen in one direction.  It might seem that the keeps are happening twice because both reps keep some voters.  This actually does happen in STV because it happens once after the first rep wins and again after the second rep wins.  
      </p>
      <p>
        A Venn diagram works well to show how votes are kept.
      </p>
      <p>  
        <img src="venndiagram.png" />
      </p>
        <ul>
            <li>Rep #1 keeps 4 ballots. </li><li> Rep #2 keeps 4 ballots.  </li><li>They share the 2 remaining ballots. </li><li> There are 10 total ballots.  </li><li>Each rep gets 6 points.  </li><li>The total is 12 points.</li></ul>
      
      <p>  
        Result: The kept votes are 8 and the total count is 20 - 8 = 12.  <b>We have a measure of voter support!  Let's maximize it!</b>
        </p>
        <p>
        Option: If there was only one candidate running, the score would be 10, which is lower, so it is good that this second candidate is running.
        </p>
        <p>
        Now consider what would happen if a 3rd candidate tried to run.
        </p>
        <p>
        Say the full table for all the reps is this:
        \[
            \begin{bmatrix}
                10 & -4 &  0 &  0 \\
                -4 & 10 &  0 &  0 \\
                 0 &  0 & 10 & -4 \\
                 0 &  0 & -4 & 10 \\
            \end{bmatrix}
        \]
        This is actually kinda simple because there are 4 seats and 4 reps, so all the reps win.  But Let's see what happens if we add a 5th rep on one side.
                    \[
            \begin{bmatrix}
                10 & -4 &  0 &  0 &  0 \\
                -4 & 10 &  0 &  0 &  0 \\
                 0 &  0 & 10 & -4 & -4 \\
                 0 &  0 & -4 & 10 & -4 \\
                 0 &  0 & -4 & -4 & 10 \\
            \end{bmatrix}
        \]

        </p>
        <p>
        If a third candidate ran, then the kept votes would add up faster than the support. Just look at the lower right part of the table.  The kept votes are 6 * 4 = 24.  The score would be 30 - 24 = 6.  That's 2 points per rep, and points per rep is a good figure of merit for deciding on an individual rep.  This is less than the score when 2 reps won, so it is not optimal for 3 reps to win. 
        </p>
        <p>
        So the idea of the quota is borrowed from Droop's quota in STV and it seems to work well here.  We also gained a nice representation of the tally as a table.
      </p>
      <h3> Finishing the Model: Similarity </h3>
      <p>
        What if the voters don't fall into parties? (like the short example above) 
      </p>
      <p>
        How much of the ballot should the rep keep?  Let's look at one voter. If a voter likes a rep more, then that rep should keep a bigger portion of the ballot.  That vote is kept from other reps.  The more the voter likes those other reps, the more the other reps lose.  So there are two numbers to multiply.
        \[
        b_{ij} * b_{ik} = \text{Voter i likes rep j and rep k this much}
        \]
        Oh yeah, we actually want this number as a fraction of the total tally for each rep.  Now we define a new constant (not a variable).
        \[
          \begin{align}
        \frac{b_{ij}}{tally_j} * \frac{b_{ik}}{tally_k} = & \text{ Rep j and rep k share the support of voter i as a fraction of their total support.} \\
        \sum_{i \in Voters} \frac{b_{ij}}{tally_j} * \frac{b_{ik}}{tally_k} = & \text{ Similarity between rep j and rep k}
        \end{align}
          \]
        Ha, so we have a measure of similarity!  Actually there are many measures of similarity.  Is this the right one?  I tried a measure called cosine similarity at first because a lot of people use it.  It treats the ballots in support of a rep as a vector.  It is a vector in many dimensions because there are many voters.  Instead of the tally, we use the length of the vector, the Euclidean distance.  This is called cosine similarity.
          \[
          s_{jk} = \frac{\sum_{i \in Voters} b_{ij} * b_{ik}}{\sqrt{\sum_{i \in Voters} b_{ij}^2} *  \sqrt{\sum_{i \in Voters} b_{ik}^2}}  = \text{Cosine similarity between rep j and rep k}
          \]
      </p>
      <p>
        So, how much of the ballot should the rep keep?
        \[
            keeps_{jk} = keep * s_{jk}
        \]
        <b>Now we have a new table to add up and maximize!  This is better than the table in the simple example because now the voters don't have to fall into parties.</b> (By the way, with this kind of method of elections, we don't need parties.)
      </p>
      <p>
        This is the part of the model where we say what we want to maximize.  This part is called the objective function.
        \[
        O = \sum_{j \in Reps} tally_j * x_j - \sum_{j \in Reps,k \neq j} keeps_{jk} * x_j * x_k
        \]
        Remember the $x$ is binary, so it's basically just letting us add up tally and keeps for the winning reps.
      </p>
      <p>
        There is a really easy way to visualize what the model is trying to do.  We reduced the problem to crossing out the rows and columns in a table.  Cross out the row and column for each rep that lost. Add the remaining tallies and keeps.
        \[
          \begin{bmatrix}
        10 & -4 & -3 &  0 & -1 \\
        -4 & 10 & -3 &  0 & -1 \\
        -3 & -3 &  8 & -2 &  0 \\
         0 &  0 & -2 & 11 &  0 \\
        -1 & -1 &  0 &  0 & 17 \\
          \end{bmatrix}
        \]
          Try to find the 4 winners by crossing out the losing rep's row and column.
      </p>
      <p>
      <img src="./crossout.png">
      </p>
      <p>
      The solution is to cross out the 3rd rep's row and column.  He had the lowest tally overall and he also overlapped in similarity with most of the other reps, so basically his territory was covered better by the other reps.
      </p>
      <p>
        <b>At last, we set a constraint on the $x_j$ variables because there are only a limited number of seats in the legislature.</b>  We set the sum of all $x_j$ to this number of seats.
        \[
        \sum_{j \in Reps} x_j = \text{number of seats}
        \]
      <p>
        <b>To sum up, the model has variables $x_j$ that work with a table of measurements.  We maximize a sum with terms that multiply the variables once by each other (quadratic binary terms) and by the table of measurements.   There is a constraint on the sum of these variables.  Gurobi takes care of the search algorithm to find the maximum among a really large number of combinations (think factorial!).</b>
      </p>
      <p>
        The problem is defined by the following model in the variable $x_j$ :

        \[
        \begin{array}{ll}
        \text{maximize}   & {\displaystyle \sum_{j \in Reps} tally_j * x_j - \sum_{j \in Reps,k \neq j} keeps_{jk} * x_j * x_k } \\
        \text{subject to} & {\displaystyle \sum_{j \in Reps} x_j} = \text{number of seats}, \\
                          & x_j \in \{ 0, 1 \} \\
        \text{constants} & keeps_{jk} = keep * s_{jk},\\
                          & s_{jk} = \frac{\sum_{i \in Voters} b_{ij} * b_{ik}}{\sqrt{\sum_{i \in Voters} b_{ij}^2} *  \sqrt{\sum_{i \in Voters} b_{ik}^2}}  = \text{Cosine similarity between rep j and rep k},\\
                          & keep = \frac{\sum_{i \in Voters} \max_{j \in Reps} b_{ij}}{seats + 1} = \text{Amount of ballots kept (if s=1, e.g. for clones)},\\
                          & tally_j = \sum_{i \in Voters} b_{ij} = \text{(add up the ballots)},\\
                          & b_{ij} = \frac{1}{d_{ij}/10 + 1} \text{ (ballot)},\\
                          & d_{ij} = \text{distance between voter i and rep j on the map}
        \end{array}
        \]

      </p>

    </div>
    <div class="example_section" id="implementation">
      <h2><a href="#implementation" name="implementation">Implementation</a></h2>
      <p>Below is an example implementation of the model with example data in
        Gurobi's Python interface:
      </p>
        <p>
            For the full implementation, see <a href="https://github.com/paretoman/searchingforparliament">https://github.com/paretoman/searchingforparliament</a>.
        </p>
<examplecode>
from gurobipy import *
import math
import numpy

# Problem data
voters = [[c1,c2] for c1 in range(10) for c2 in range(10)]
reps = [[f1*3+1.5,f2*3+1.7] for f1 in range(3) for f2 in range(3)]
numReps = len(reps)
numVoters = len(voters)

# Add variables
m = Model()
x = {}
for j in range(numReps):
    x[j] = m.addVar(vtype=GRB.BINARY, name="x%d" % j)

# Add constants
d = numpy.zeros((numVoters,numReps))
b = numpy.zeros((numVoters,numReps))
s = numpy.zeros((numReps,numReps))
t = numpy.zeros(numReps)

def distance(a,b):
  dx = a[0] - b[0]
  dy = a[1] - b[1]
  return math.sqrt(dx*dx + dy*dy)

for i in range(numVoters):
    for j in range(numReps):
        d[i,j] = distance(voters[i], reps[j])
        b[i,j] = 1 /( d[i,j]/10 + 1 )

def cosine_similarity(a,b):
    return numpy.dot(a,b) / numpy.sqrt(numpy.sum(a**2) * numpy.sum(b**2))

for j in range(numReps):
    for k in range(numReps):
        s[j,k] = cosine_similarity(b[:,j],b[:,k])
    t[j] = sum(b[:,j])
keep = sum(numpy.max(b,1)) / (1+5)

m.update()

# Add constraints
m.addConstr(quicksum(x[j] for j in range(numReps)) == 5)

d_obj = LinExpr()
for j in range(numReps):
    d_obj += t[j]*x[j]
    for k in range(numReps):
        if k != j:
            d_obj += -keep*s[j,k]*x[j]*x[k]

m.setObjective( d_obj , GRB.MAXIMIZE)

m.optimize()

# Output
print(["%d" % x[j1].X for j1 in range(9)])

</examplecode>
    </div>
    <div class="example_section" id="demo">
      <h2><a href="#demo" name="demo">Live Demo</a></h2>

      <p>
        Below is a visualization of our example. We are using the
        location data from <a href="#geolytix">GeoLytix</a> for a large
        supermarket chain in the UK, and visualizing its outlets in
        Northern England. (This is an approximation to population distribution.)
      </p>

      <p>
        The voters are represented by:
        <svg height="20" width="20">
      <circle cx="10" cy="15" r="3" fill="black" opacity=".5" />
    </svg>
      </p>

      <p>
        By clicking the map you can add <em>potential</em> rep locations.
        These are drawn as:
        <svg height="20" width="20">
      <circle cx="10" cy="10" r="8" stroke="black" stroke-width="1" fill="white" />
    </svg>
      </p>
      <p>
        Click "Compute Winners" to find the reps who will win. These will be drawn as:
        <svg height="20" width="100">
      <circle cx="10" cy="10" r="8" stroke="#000099" stroke-width="3" fill="blue" />
          <circle cx="30" cy="10" r="8" stroke="#006600" stroke-width="3" fill="green" />
          <circle cx="50" cy="10" r="8" stroke="#990000" stroke-width="3" fill="red" />
          <circle cx="70" cy="10" r="8" stroke="#999900" stroke-width="3" fill="yellow" />
          <circle cx="90" cy="10" r="8" stroke="#404040" stroke-width="3" fill="gray" />
    </svg>
      </p>

      <p>
        A few potential rep locations have already been set up, but
        you can add more by clicking the screen.
      </p>
	  
	  
	  		<aside style="width:150px">
		<div id="options" style="display:none">
		<form>
		<fieldset>
		<legend>Keeps:</legend>
		<input type="range" min = 500000 max = 3000000 step = 500000 id="cost" value="1000000" oninput="outputUpdate(value)" class="slider-width" style="width:100px"> <br />
		<output for=cost id=costDisplay>1.0</output> Multiplier <br />
		<input class="op" type="radio" name="keeps" checked="true">	Seats Plus One <br />
		<input class="op" type="radio" name="keeps">	Seats Plus Half <br />
		<input class="op" type="radio" name="keeps">	Seats Plus Zero <br />
		</fieldset>
		<fieldset>
		<legend>Ballot:</legend>
		<input class="op"  checked="true"  type="checkbox">	Normalize <br />
		<input class="op" checked="true"  type="radio" name="ballots"> 	1 / Distance<br />
		<input class="op" type="radio" name="ballots">
		Exponential <br />
		<input class="op" type="radio" name="ballots"> 	Threshold (todo) <br />
		</fieldset>
		<fieldset>
		<legend>Similarity Measure:</legend>
		<input class="op" checked="true"  type="radio" name="similarity"> Cosine<br />
		<input class="op" type="radio" name="similarity"> L1<br />
		<input class="op" type="radio" name="similarity"> Jaccard (todo) <br />
		</fieldset>
		<fieldset>
		<legend>Computation:</legend>
		<input class="op" checked="true" type="radio" name="compute"> Our Binary Quadratic Problem as described above. <br />
		<input class="op" type="radio" name="compute"> STV <br />
		<input class="op" type="radio" name="compute"> Plurality Multiwinner <br />
		<input class="op" type="radio" name="compute"> Schulze STV <br />
		<input class="op" type="radio" name="compute"> Clustering like original<br />
		<input class="op" type="radio" name="compute"> A new formulation (working on it) 
	    </fieldset>
		<fieldset>
		<legend>Map:</legend>
		<input type="range" min = .1 max = 1 step = .1 id="zoom_id" value="1" oninput="updateZoom(value)" class="slider-width" style="width:60px">Zoom<br />
		<input type="range" min = -1 max = 1 step = .1 id="xshift_id" value="0" oninput="updateXshift(value)" class="slider-width" style="width:60px">X<br />
		<input type="range" min = -1 max = 1 step = .1 id="yshift_id" value="0" oninput="updateYshift(value)" class="slider-width" style="width:60px">Y<br />
		</fieldset>
		</form>
		</div>
	    </aside>
	  
      <div id="demoarea">
      </div>
	  
      <div id="spinnerdiv">
      </div>
	  <p>
      <button class="pure-button" onclick="compute()">Compute Winners</button>
      <button onclick="restart()">Restart</button>
	  <button class="pure-button" onclick="toggle_options()">Beast Mode</button>
	  <button class="pure-button" onclick="toggle_div()">Gurobi Log</button>
	  </p>
	  
      <p>
          <script>
			var cost;
			var numberOfWinners;
			function outputUpdate(value) {
			  document.querySelector('#costDisplay').value = value/1000000;
			}
			function numberOfWinnersUpdate(value) {
			  document.querySelector('#numberOfWinnersDisplay').value = value;
			}
			function updateZoom(value) {
			  zoomit = value;
			  draw_map();
			}
			function updateXshift(value) {
			  xshift = value;
			  draw_map();
			}
			function updateYshift(value) {
			  yshift = value;
			  draw_map();
			}
		  </script>  
		<input type="range" min = 1 max = 20 step = 1 id="numberOfWinners" value="5" oninput="numberOfWinnersUpdate(value)" class="slider-width" style="width:200px">
		<output for=numberOfWinners id=numberOfWinnersDisplay>5</output> Winners <br />

      </p>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
      <script>
        function toggle_div() {
          var logfile = d3.select('#logfile');
          if (logfile.style("display") === "none") {
            logfile.style("display", "block");
          } else {
            logfile.style("display", "none");
          }

        }
		function toggle_options() {
          var optionsdiv = d3.select('#options');
          if (optionsdiv.style("display") === "none") {
            optionsdiv.style("display", "block");
          } else {
            //optionsdiv.style("display", "none"); //actually we don't want to cause confusion.  If you activate beast mode, you can't go back.
          }

        }
      </script>

      <examplecode id=logfile>
      </examplecode>

      
    </div>
	
	<p>
        <button id="morebutton" class="pure-button" onclick="toggle_readmore()">Read More</button>
      </p>


      <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
      <script>
		function toggle_readmore() {
          var readmorediv = d3.select('#readmore');
          readmorediv.style("display", "block");
          var mb = d3.select('#morebutton');
          mb.style("display", "none");

        }
      </script>
	<div id="readmore" style="display:none">
	
     <p>
		There is also a beast mode where you can see different computations.  STV is included.  There is a clustering computation similar to the project this was forked from.  And I am working on a new optimization based on a form of reweighted range voting (as of now it takes too long, maybe about a minute to run).  Also, there are different ballot types, an option for disabling normalization, an option for adding a +1 to the seats. Also, there are different similarity measures.  Also, you can change the amount of keeps to see how it allows for a proportional distribution of winners.
      </p>
	  <p style="font-size:8px">
        <a name="geolytix">Location data:</a>
        <a href="http://geolytix.co.uk/downloads/OpenSupermarkets.zip">Supermarket
        locations &copy; GeoLytix</a> copyright and database right 2014.
      </p>
    <div class="example_section" id="try">
      <h2><a href="#try" name="try">How to use Gurobi</a></h2>
      <p> Here is a link to Gurobi.  I kept it here because I forked this project from Emilien Dupont (on <a href="https://github.com/EmilienDupont/facilityLocation">github</a> and hosted as <a href="http://examples.gurobi.com/facility-location/"> a featured example on Gurobi's website</a>)
      </p>
      <p>
      I suggest using conda to install it.  And then there is a license to download, so you have to make an account on the gurobi website.  I used Python 2.
      </p>
      <div class="col_5 column">
        <a href="http://www.gurobi.com/downloads/evaluation-request">
          <button class="red stack-button">
            <i class="fa fa-lg fa-line-chart"></i>
            Commercial Users: Free Evaluation Version
          </button>
        </a>
      </div>
      <div class="col_5 column">
        <a href="http://www.gurobi.com/downloads/download-center">
          <button class="red stack-button">
            <i class="fa fa-lg fa-line-chart"></i>
            Academic Users: Free Academic Version
          </button>
        </a>
      </div>
      
      <div class="example_section" id="thoughts">
      <h2>Here's my thoughts.</h2>
      <p>
      It turns out I finally invented a good voting system.  So, how did I come up with it?  Well, I had thought of it before but couldn't work out the math.  It is the same as STV because it has a quota.  It is different than STV because it searches for the best combination of candidates that would maximize voter support for the winners.  
        </p>
        <p>
        I didn't think it would work.  I thought I was over-penalizing.  However, I realized that I could set the quota so that it optimized the number of candidates coming from a voter base.  The optimization is for proportionality.  I tried to use the same quota as STV's droop quota: number of voters over number-of-seats-plus-1.  
        </p>
        <p>
        Some things to change:  I'm not sure exactly what the quota should be because I'm not sure how they'll actually vote.  Right now, I have put them as all voting depending on their distance from a candidate.  Maybe I would choose a different function.  Maybe voters would want to maximize the range of their vote.  Maybe they would have just two levels of support, high and low, and they would change their threshold depending on who is running and who other people are voting for.
        </p>
        <p>
        Things to do.
        </p>
        <p>
          <ul><li>compare to clustering
        </li><li>normalize votes
        </li><li>try exponential choice function
        </li><li>try linear choice function
        </li><li>try threshold choice function
        </li><li>add STV comparison
        </li><li>add CPO-STV comparison
        </li><li>far future: put this into ncase's better ballot.
        </li><li>far future: yee diagram in background
        </li><li>explanation: what is the incentive of the voters to vote honestly?  Couldn't they find a way to avoid penalties by only supporting one candidate?  Isn't that strategy also applicable to STV?
        </li></ul>
          </p>
        <p>
        So basically what I was thinking was to write out a matrix of the penalties.  Then show that the penalties lead to a correct number of representatives for this voter-base.  
        </p>
        <p>
        In clustering, voters dont have influence outside their cluster.  In this penalty system, they can have negative influence if they get too many representatives... maybe.. but they would never get too many
        </p>
        <p>
        I need to motivate this with the idea of search.  There is depth-first, which is greedy and assigns the single candidates with the highest vote counts first.  Standard STV does this kind of depth-first search.  In STV, if more people like a candidate than the quota, then those people can get their second choices as well.  This is like at-large voting, except after your candidate gets a seat, part of your vote stays with them and only part of it gets to go to a second candidate.  This kind of division of the vote can be accomplished by subtracting the "kept" votes from the total vote count.  This avoids overcounting.
        </p>
        <p>
        The algorithm searches through all the possible combinations of seat assignments for the candidates.  It tries to maximize the number of voters who support the winning candidates.  It avoids double-counting in the same way as STV.  It keeps some of the votes for similar candidates.
        </p>
        <p>
        Basically, this cosine similarity is a measure of an angle.  It is not a typical angle.  It is not in 2 dimensions.  It is actually in many more dimensions, as many dimensions as there are candidates.  Still, the same idea holds in 2 dimensions that the more aligned 2 candidates are, the bigger the cosine similarity.  It ranges from 0 for candidates that have nothing in common to 1 for identical "clone" candidates.
        </p>
        <p>
        This information gets put into the problem definition matrix by simply multiplying each entry by cosine similarity.  Even the diagonals work! It's actually pretty easy.
        </p>
        <p>

        Now we just tell the optimization software to pick the 5 best rows and columns that have the biggest sum.  Those are the best winners.
        </p>
        <p>
        Here's a demo.
        </p>
        <p>
        You can see that some areas have 2 candidates close together.  This one cluster of voters is big enough and supportive enough (close to the candidates), to elect 2 candidates.
        </p>
        <p>
        Of course there are details I left out.
        </p>
        <p>
        These are just my thoughts.
        </p>

      </div>

    </div>
    </div>

    <div style="min-height:100px"></div>

<!--[if gt IE 8]><!--><script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script><!--<![endif]-->
<script src="jquery.nav.js"></script>
<script>
  $(document).ready(function() {
  console.log('calling onePageNav');
  $('#nav').onePageNav({scrollOffset:120});
  });
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/spin.js/1.2.7/spin.min.js"></script>
<script>

// Hide Log File intially
d3.select('#logfile').style("display", "none");

//Width and height
var width = 800;
var height = 500;
var padding = 30;
var miles_per_px = 0.19;
var price_per_px = 3*miles_per_px;
var alpha = 5*365*price_per_px; // Consider the cost over 5 years
alpha = alpha * 1754385.964912 * 0.000548 // let's change alpha for "keep"
alpha = 1000100
alpha = 1000000
var spinner;

var svg = d3.select("#demoarea")
              .append("svg")
              .attr("width", width)
              .attr("height", height);

// Potential sites for facilities
var sites = [[.3*width, .8*height], [.4*width, .3*height], [516.40625, 380.34375],
             [486.40625, 55.34375], [766.40625, 179.34375], [728.40625, 439.34375]];

var cost = parseFloat(document.getElementById("cost").value)/alpha;

var charge = d3.range(sites.length).map(function(d) { return cost; });


// G object for background
var backgroundG;

// G object for map
var mapG;

// G object for animations
var animationG;

// G object for sites
var sitesG;

// G object for points
var circleG;

// G object for voronoi
var pathG;

// G object for facilities
var facilitiesG;

// G object for location names
var locationG;

// G object for clickable areas
var clickableG;

// G object for spinner
var spinnerG;

var zoomit = 1;
var xshift = 0;
var yshift = 0;
var projection;
var path;
var vertices;

var places;
var counties;



function draw_map() {
    
// G object for background
backgroundG = svg.append("g");

// G object for map
mapG = svg.append("g");

// G object for animations
animationG = svg.append("g");

// G object for sites
sitesG = svg.append("g");

// G object for points
circleG = svg.append("g");

// G object for voronoi
pathG = svg.append("g");

// G object for facilities
facilitiesG = svg.append("g");

// G object for location names
locationG = svg.append("g");

// G object for clickable areas
clickableG = svg.append("g");

// G object for spinner
spinnerG = svg.append("g").attr("id", "spinid");


backgroundG.append("rect")
           .attr("x", 0).attr("y", 0)
           .attr("width", width).attr("height", height)
           .attr("fill", "#A3CCFF"); // "#66B2FF"
		   

sitesG.selectAll("circle")
       .data(sites)
       .enter()
       .append("circle")
       .attr("cx", function(d) { return d[0]; })
       .attr("cy", function(d) { return d[1]; })
       .attr("class", "site")
       .attr("r", 5);

var mapColors = [];
var maxRed = 247, minRed = 116;
var maxGreen = 252, minGreen = 196;
var maxBlue = 245, minBlue = 118;
var maxRed = 247, minRed = 116+100;
var maxGreen = 252, minGreen = 196+50;
var maxBlue = 245, minBlue = 118+100;
var maxRed = 247, minRed = 203;
var maxGreen = 252, minGreen = 230;
var maxBlue = 245, minBlue = 163;
var numColors = 40;
for (var i = 0; i < numColors; i++) {
  var red = String( Math.round( minRed + (maxRed - minRed)*i/numColors ) );
  var green = String( Math.round( minGreen + (maxGreen - minGreen)*i/numColors) );
  var blue = String( Math.round( minBlue + (maxBlue - minBlue)*i/numColors ) );
  mapColors.push( "rgb(" + red + "," + green + "," + blue + ")");
}


	projection = d3.geo.albers()
		.center([.2, 53.6 + yshift*3])
		.rotate([2.4 + xshift* -3, 0])
		.parallels([50, 60])
		.scale(1200 * 20 * zoomit)
		.translate([width / 2 , height / 2]);
	path = d3.geo.path()
		.projection(projection);

	d3.json("UKwithCounties.json", function(error, uk) {
	  d3.json("supermarket.json", function(supermarket) {
		vertices = [];
		// Set up map of UK
		places = topojson.feature(uk, uk.objects.placesUK);
		counties = topojson.feature(uk, uk.objects.ukcounties).features;

		mapG.selectAll("path")
			.data(counties)
			.enter()
			.append("path")
			.attr("d", path)
			.attr("fill", function(d,i) { return mapColors[i % 10 + 10]; })
			//.attr("fill", function(d,i) { return mapColors[i % 9]; })
			//.attr("fill", function(d,i) { return mapColors[i%3+7]; })
			//.attr("fill","#CBE6A3")
			//.attr("stroke", "rgb(150,150,150)")
			;

		clickableG.selectAll("path")
			.data(counties)
			.enter()
			.append("path")
			.attr("d", path)
			.attr("opacity", 0)
			.on("mousedown", addPoint);

		locationG.append("path")
				 //.datum(places)
				 .attr("d", path)
				 .attr("class", "place");

		locationG.selectAll(".place-label")
				.data(places.features)
				.enter().append("text")
				.attr("class", "place-label")
				.attr("transform", function(d) { return "translate(" + projection(d.geometry.coordinates) + ")"; })
				.attr("x", function(d) { return d.geometry.coordinates[0] > -1 ? 6 : -6; })
				.attr("dy", ".35em")
				.style("text-anchor", function(d) { return d.geometry.coordinates[0] > -1 ? "start" : "end"; })
				.text(function(d) { return d.properties.name; })
				.attr("font-family", "Helvetica Neue")
				.attr("font-size", 15)
				.attr("font-weight", 400);

		// Set up supermarket locations
		// Add locations to vertices array
		circleG.selectAll("circle")
			   .data(supermarket)
			   .enter()
			   .append("circle")
			   .filter(function(d) {
				  var loc = projection([d.LongWGS84, d.LatWGS84]);
				  return ( loc[0] >= 0 && loc[0] <= width && loc[1] >= 0 && loc[1] <= height);})
			   .attr("cx", function (d) { var loc = projection([d.LongWGS84, d.LatWGS84]);
										  vertices.push([parseFloat(loc[0]), parseFloat(loc[1])]);
										  return loc[0]; })
			   .attr("cy", function (d) { var loc = projection([d.LongWGS84, d.LatWGS84]);
										  return loc[1]; })
			   .attr("r", 2)
			   .attr("class", "client");

		console.log('number of vertices', vertices.length);
	  });
	});
	
	if (zoomit != 1 || xshift !=0 || yshift !=0) restart(); // really I'd like to keep some initial points but it wasn't working.
}

draw_map();

function addPoint() {
  facilitiesG.selectAll("circle").remove("circle");
  animationG.selectAll("circle").remove("circle");
  pathG.selectAll("line").remove("line");

  var point = d3.mouse(this);
  console.log('point', point);
  sites.push(point);
  sitesG.append("circle")
         .attr("cx", point[0])
         .attr("cy", point[1])
         .attr("class", "site")
         .attr("r", 5);
  charge.push(cost);

  // Add animation
  animationG.selectAll("circle").remove("circle");
  var anim = animationG.append("circle")
                        .attr("cx", point[0])
                        .attr("cy", point[1])
                        .attr("r", 0)
                        .attr("fill", "black");

  anim.style("opacity", .5)
      .transition()
      .style("opacity", 0)
      .attr("r", 20)
      .duration(200)
      .ease("out");
}

function compute() {

  if (sites.length < 1) {
    alert("Add potential sites to compute the optimal facility locations!");
    return;
  }

  facilitiesG.selectAll("circle").remove("circle");
  animationG.selectAll("circle").remove("circle");
  pathG.selectAll("line").remove("line");

  // Show loading screen
  spinnerG.append("rect")
          .attr("x", 0).attr("y", 0)
          .attr("width", width).attr("height", height)
          .attr("fill", "white")
          .attr("opacity", .5);

  spinnerG.append("text")
          .attr("x", width/2)
          .attr("y", .4*height)
          .attr("font-size", 25)
          .attr("font-family", "Helvetica Neue")
          .attr("font-weight", 400)
          .attr("text-anchor", "middle")
          .text("Computing...");

  var target = document.getElementById('demoarea');
  spinner = new Spinner({left: '375%'}).spin(target);

  // options
  cost = parseFloat(document.getElementById("cost").value)/alpha;
  numberOfWinners = parseFloat(document.getElementById("numberOfWinners").value);
  charge = [];
  charge.push(numberOfWinners);
  charge.push(cost);
  var ops = document.getElementsByClassName('op');
  for(var i = 0; i < ops.length; i++){
	charge.push( 0 + ops[i].checked);
  }
  
  d3.json('facility.py')
    .header('Content-Type', 'application/json')
    .post(JSON.stringify({'clients': vertices,
                          'facilities': sites,
                          'charge': charge}), serverResponse);
}

function serverResponse(error, data) {
  console.log('serverResponse');
  console.log('data', data);

  // Remove loading screen
  spinnerG.selectAll("rect").remove("rect");
  spinnerG.selectAll("text").remove("text");
  spinner.stop();

  if (!error) {
      if ('solution' in data) {
          // Import solution and put it into correct format
          var solution = data['solution'];
          if (solution[0] === "error") {
            alert("10 second solve time limit exceeded. Reduce the number of the candidate facilities.");
            return;
          }
          var solution1 = solution[0]; // Facilities to open
          var solution2 = solution[1]; // Edges to draw
          var logMsg = solution[2]; // Log message to display

          d3.select('#logfile').html(logMsg);

          var facilities = [];

          for (var i = 0; i < solution1.length; i++) {
            facilities.push(sites[solution1[i]]);
          }

          facilitiesG.selectAll("circle").remove("circle");
          animationG.selectAll("circle").remove("circle");

          var faci = facilitiesG.selectAll("circle")
                     .data(facilities)
                     .enter()
                     .append("circle")
                     .attr("cx", function(d) { return d[0]; })
                     .attr("cy", function(d) { return d[1]; })
                     .attr("class", function(d, i) { return "c" + i % 5; })
                     .attr("r",60)
                     .attr("stroke-width", 2);

          var anim = animationG.selectAll("circle")
                     .data(facilities)
                     .enter()
                     .append("circle")
                     .attr("cx", function(d) { return d[0]; })
                     .attr("cy", function(d) { return d[1]; })
                     .attr("class", function(d, i) { return "c" + i % 5; })
                     .attr("r",0)
                     .attr("stroke-width", 0);

          faci.style("opacity", 0)
              .style("stroke-opacity", 0)
              .transition()
              .style("opacity", 1)
              .style("stroke-opacity", 1)
              .attr("r", 6)
              .duration(500)
              .delay(function(d, i) { return i*100 });

          anim.style("opacity", .5)
              .style("stroke-opacity", .5)
              .transition()
              .style("opacity", 0)
              .style("stroke-opacity", 0)
              .attr("r", 30)
              .duration(500)
              .ease("out")
              .delay(function(d, i) { return i*100 + 300});

          pathG.selectAll("circle").remove("circle");

          var connections = pathG.selectAll("circle")
                                 .data(solution2)
                                 .enter()
								 .append("circle")
								 .attr("r", 2)
								 .attr("cx", function(d) { var loc = vertices[d[0]]; return loc[0]; })
                                 .attr("cy", function(d) { var loc = vertices[d[0]]; return loc[1]; })
                                 .attr("class", function(d) {   var n = solution1.indexOf(d[1]);
                                                                return "v" + n % 5; })
                                 .attr("opacity", 0);

          connections.transition()
                     .attr("opacity", .6)
                     .duration(500)
                     .delay(0);
		  circleG.transition()
                     .attr("opacity", 0)
                     .duration(500)
                     .delay(0);
		  
        }
      }
}


function restart() {
  sitesG.selectAll("circle").remove("circle");
  facilitiesG.selectAll("circle").remove("circle");
  animationG.selectAll("circle").remove("circle");
  pathG.selectAll("circle").attr("class", "client").attr("r",2);
  sites = [];
}

</script>


