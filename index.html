<!DOCTYPE html>
<meta charset="utf-8">
<meta name="viewport" content="initial-scale=1">
<script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML">
</script>
<script>
  MathJax.Hub.Config({
                      tex2jax: {inlineMath: [['$', '$'], ['\\(','\\)']]},
                      TeX: { equationNumbers: {autoNumber: "AMS"} },
                      "HTML-CSS": { showMathMenu: false,
                                    scale: 90 }
                     });
</script>
<link rel="stylesheet" href="base.css">
<style>
a:hover.screenshot {
  opacity: .7;
}

.site {
  fill: white;
  stroke: black;
  stroke-width: 1;
}

.client {
  fill: black;
  opacity: .5;
}

.c0 { fill: blue; stroke: #000099 }
.c1 { fill: green; stroke: #006600 }
.c2 { fill: red; stroke: #990000}
.c3 { fill: yellow; stroke: #999900 }
.c4 { fill: gray; stroke: #404040 }

.v0 { fill: blue; stroke: #000099 }
.v1 { fill: green; stroke: #006600 }
.v2 { fill: red; stroke: #990000}
.v3 { fill: yellow; stroke: #999900 }
.v4 { fill: gray; stroke: #404040 }

.place,
.place-label {
  fill: black;
  opacity: 1;
  stroke: none;
}

</style>
<body>
<ul id="nav2">
    <li class="current"><a href="#intro">Intro</a></li>
    <li><a href="#problem">Problem</a></li>
    <li><a href="#model">Model</a></li>
    <li><a href="#implementation">Implementation</a></li>
    <li><a href="#demo">Live Demo</a></li>
    <li><a href="#try">How to set up.</a></li>
  </ul>
  <div id="example_container">
    <div class="example_section" id="intro">
      <h1>Searching for Parliament</h1>
        <subtitle>(the computer science kind of search)</subtitle>
    </div>
    <p>
      Selecting a group of people to represent a nation is an example of what computer science calls an assignment search problem.  Which candidates are the most representative of the voters?
    </p>

    <p>
      We'll construct a mathematical model of the assignment search problem, implement this model in the Python programming language with an optimization package called Gurobi, and compute and visualize an optimal solution.
    </p>

    <p>
      The implementation of the model and the structure of this explanation is forked from the work of Emilien Dupont (on <a href="https://github.com/EmilienDupont/facilityLocation">github</a> and hosted as <a href="http://examples.gurobi.com/facility-location/"> a featured example on Gurobi's website</a>).  The code for this website is (on <a href="https://github.com/paretoman/searchingforparliament">github</a>.
    </p>

    <h3>
      Click the screenshot to skip directly to the Live Demo!
    </h3>
    <p>
      <a href="#demo" class="screenshot">
        <img src="screenshot.png" alt="Live Demo" style="width: 100%; vertical-align: middle;">
      </a>
    </p>


    <div class="example_section" id="problem">
      <h2><a href="#problem" name="problem">Problem Description</a></h2>

    <div style="float:right;">
      <a href="https://en.wikipedia.org">
        <img src="Sir_Gerald_Kaufman.jpg" alt="Sir_Gerald_Kaufman" style="width:200px;">
      </a>
    </div>

    <p>Northern England gets rid of district boundaries because there was too much debate about where the boundaries should go.  It wants to elect 4 reps (representatives).  And it wants to space them out instead of having them all from the middle.  It wants regional interests to be represented and it doesn't want all the seats to be taken by people from the same neighborhood in the middle of Northern England.</p>

    <p>Several good potential reps have decided to run, but it remains to decide which of the reps should win.</p>

        <aside> A typical rep.<span style="font-size: 10px"></span>
    </aside>

    <p>Selecting reps from the middle of Northern England would be advantageous as they would have the most votes overall.  However, voters from the middle of Northern England would be overrepresented and voters from the coast would be very far from their from their reps.</p>

    <p>We will find the optimal tradeoff between reps being near all the voters and voters having reps nearby.</p>

    <h3> Search Trees </h3>
      <p>
        Our problem is related to a very famous problem in computer science called the knapsack problem.  It differs in many ways.  It is similar in how it can be solved.  Both are kinds of binary search.  A search problem tries to find a combination of variables that is in some way the best combination.  One way to approach such a problem is the branch and bound method.  Here is a video on the <a href="https://www.coursera.org/learn/discrete-optimization/lecture/66OlO/knapsack-5-relaxation-branch-and-bound">branch and bound method</a> from a fantastic Coursera course in the field of <a href="https://www.coursera.org/learn/discrete-optimization/">discrete optimization</a>.  From this video, just understand that <b>there is a large number of possible choices to make and that they can all be organized in a tree structure</b>.  (The actual algorithm for searching through the tree will be taken care of by Gurobi, and we don't talk about it below.)  We still haven't said what the score is for each choice (or path) in the tree, so let's do that.  Most of the writing below is about that.  Each choice in the tree represents whether a rep wins.  The first split is for the first rep, the second split is for the second rep, etc.
      </p>
        <p> 
        <img src = "./tree.png" />
        </p>
      <p>
          This tree is not for the problem at hand, but our problem is similar because it has the same binary variables $x_i$.
	  </p>
    </div>

    <div class="example_section" id="model">
      <h2><a href="#model" name="model">Mathematical Model</a></h2>
      <p>
        Let us now formulate a mathematical model for our problem.
      </p>
	    
      <p>
        We need to say when we choose a rep.  Let's list all the reps as rep #1, rep #2, rep #3, etc, and let's make variables for each one.  If we choose rep #1, then $x_1=1$ and if we don't choose rep #2, then $x_2=0$.  Basically, $x_j$ is binary.
        \[
        x_j = \left\{\begin{array}{ll}
               1 & \text{if we choose rep #j, }\\
               0 & \mathrm{otherwise.}
              \end{array}\right.
        \]
		We set a constraint on the $x_j$ variables because there are only a limited number of seats in the legislature.  We set the sum of all $x_j$ to this number of seats.
        \[
        \sum_{j \in Reps} x_j = \text{number of seats}
        \]
      </p>
      <p>
        We need to say how close a voter is to a rep.  Let's list all the voters as voter #1, voter #2, etc, and let's make measurements for each voter and rep combination.  If the distance between voter #1 and rep #3 is 100 km, then $d_{13}=100$.
        \[
        d_{ij} = \text{distance between voter i and rep j}
        \]
      </p>

      <p>
        What does a ballot look like? We want to make this problem easy to show on a map so we're going to make a simplification of the problem.  We're going to let the voters give the candidates scores.  This is actually nicer for the voters because they get to say what they think of every rep.  Also, we're going to make every voter use the same scoring scale, and they will base their score entirely on how far away the rep is.  Basically, the inverse of distance.
        \[
		\begin{array}{ll}
        a_{ij} & = {\displaystyle \frac{1}{d_{ij}/10 + 1} } & \text{Inverting distance}\nonumber \\
		b_{ij} & = {\displaystyle a_{ij} * \frac{1}{\max_{m \in Voters}{a_{mj}}}} &\text{Ballot normalized}  \nonumber
		\end{array}
        \]
      </p>
      <p>
        (The 10 is here for scaling distance.  The extra 1 is here to avoid dividing by 0.  Really, there are many choices for this function. One more modification we make is to let voters who don't have a very close candidate vote with their full vote for their closest candidate.  This normalization is here because voters would give the candidate closest to them the highest score possible even if they aren't actually all that close.) voter rep
      </p>
        <p>
        <img src="./tally.png" align="center" />
        </p> 
      <p>
        We need a way to count the ballots.  The easiest way is to add them together to get the reps' tallies.
        \[
        tally_j = \sum_{i \in Voters} b_{ij} 
        \]
      </p>
      <p>
        If we stop here then we just end up picking the candidates in the middle because they have the highest tallies.
      </p>
      <p>
        We want to avoid overrepresenting the middle voters.  Our solution is to let the winning reps keep a fraction of their voters' ballots.  Basically, these voters have the reps, so the reps get to keep the voters.  Each winning rep keeps the same amount of support.
        \[
        keep = 
			\left[
            \begin{array}{ll}
				& \text{an amount of score,} \\
				& \text{same units as ballots} \\
				& \text{same for each pair of reps} \\
            \end{array}
			\right]
        \]
		\text{an amount of score. same units as ballots.  same for each winning rep.}
        \]
      </p>
      <p>
        The idea of the rep keeping some ballots is not new.  The election method called Single Transferable Vote (STV) does the same thing.  It is different because it doesn't use scores.  It uses ranking.  Still, it is very similar.  STV calls it a quota.  
        \[
        \text{STV quota} = \frac{\text{voters}}{\text{seats} + 1}
        \]
        The quota is set as the number of voters divided by the number of seats to fill with reps.  An additional 1 is added to the number of seats because of the iterative nature of STV (a longer explanation is needed).
      </p>
      <p>
        Let's try something like the STV quota.
        \[
        keep = \frac{\text{voters}}{\text{seats}}
        \]
		We want to subtract this somehow, and we want to show why this STV-style quota selects the correct number of reps for a group of voters.
      </p>
      <h3> Mini example to show proportionality</h3>
      <p>
        Ok, we'll show an example.  We can actually see the method at work.

	    \[
        \begin{align}
        3& \text{ seats} \nonumber \\
        6& \text{ voters} \nonumber \\
        2& \text{ voters for party A: A1,A2,A3,...} \nonumber \\
        4& \text{ voters for party B: B1,B2,B3,...} \nonumber \\
        \end{align}
        \]
		
		Here are the ballots for just the parties:
				\[
		\begin{bmatrix}
		A: & 1 & 1 & 0 & 0 & 0 & 0 \\
		B: & 0 & 0 & 1 & 1 & 1 & 1 
		\end{bmatrix}
		\]
		
		Here are the tallies for each of the reps:
		\[
		\begin{bmatrix}
		A_1: & 2 \\
		A_2: & 2 \\
		B_1: & 4 \\
		B_2: & 4 \\
		\end{bmatrix}
		\]
		
		We can also write the tallies along the diagonals of this table
		
		\[
            \begin{bmatrix}
				      &A_1 &A_2 &B_1 &B_2  \\
                 A_1: &  2 &    &    &     \\
                 A_2: &    &  2 &    &     \\
                 B_1: &    &    &  4 &     \\
                 B_2: &    &    &    &  4  \\
            \end{bmatrix}
        \]
		
		Keeps happen when two reps from the same party get elected.  For every pair, there is a table entry, so lets fill in those entries with keeps.
		
		\[
			\left[
            \begin{array}{rr}
				      &A_1 &A_2 &B_1 &B_2  \\
                 A_1: &  2 & -2 &    &     \\
                 A_2: & -2 &  2 &    &     \\
                 B_1: &    &    &  4 & -2  \\
                 B_2: &    &    & -2 &  4  \\
            \end{array}
			\right]
        \]
		
		We want to choose the 3 reps with the most votes.  So we try each combination, and for each we add the tallies and subtract the keeps.
		\[
		\]
		One from A and two from B is the best combination:
		\[
			\left[
            \begin{array}{rr}
				      &A_1 &  \text{   }  &B_1 &B_2  \\
                 A_1: &  2 &    &    &     \\
                      &    &    &    &     \\
                 B_1: &    &    &  4 & -2  \\
                 B_2: &    &    & -2 &  4  \\
            \end{array}
			\right] = 2+4+4-2-2=6
        \]
		2 from A is not as good because there are a disproportionate number from A:
		\[
			\left[
            \begin{array}{rr}
				      &A_1 &A_2 &B_1 & \text{   }  \\
                 A_1: &  2 & -2 &    &     \\
                 A_2: & -2 &  2 &    &     \\
                 B_1: &    &    &  4 &     \\
                      &    &    &    &     \\
            \end{array}
			\right] =2+2+4-2-2=4
        \]
		If there were 3 winners from B, the total votes would be even less.  
		\[
			\left[
            \begin{array}{rr}
				      &    &  \text{   }  &B_1 &B_2& B_3  \\
                      &    &    &    &    &     \\
                      &    &    &    &    &     \\
                 B_1: &    &    &  4 & -2 & -2  \\
                 B_2: &    &    & -2 &  4 & -2  \\
                 B_3: &    &    & -2 & -2 & 4  \\
            \end{array}
			\right] = 4+4+4-2-2-2-2-2-2=0
        \]
		The best combination was when there the proportion of votes matched the proportion of seats.  <b>That means the way we count votes is proportional.</b>  We also gained a nice table graphic for counting votes.
		</p>
	  <h3> Proportionality </h3>
	  <p>
	    Lets do some algebra to show that this is the right number of keeps.  It might seem that the keeps in this table are happening twice.  So we will find out if the amount of keeps should be some other number.
		
	    \[
        \begin{align}
        C_t& \text{ seats} \nonumber \\
        N_t& \text{ voters} \nonumber \\
        N_A& \text{ voters for party A: A1,A2,A3,...} \nonumber \\
        N_B& \text{ voters for party B: B1,B2,B3,...} \nonumber \\
		C_A& \text{ number of winners for party A} \nonumber \\
        C_B& \text{ number of winners for party B} \nonumber \\
        \end{align}
        \]
		
		For each party, let's look at the winners add the tallies and subtract the keeps:
		
				\[
			\left[
            \begin{array}{rr}
				      & A_1 & A_2 & \text{...} & A_{C_A}  \\
                 A_1: & N_A &  -K &     &   -K   \\
                 A_2: &  -K & N_A &     &   -K   \\
                 \text{...} &     &     &     &        \\
                 A_{C_A}:  &  -K &  -K &     & N_A    \\
            \end{array}
			\right] = N_A*C_A-K*C_A*(C_A-1)
        \]
      
		What is the support per candidate?
		
		\[
			N_A-K*(C-1)
        \]
		Choose the best candidates so they all get the same votes (approximation for inifinite candidates):
		
		\[
			N_A-K*(C_A-1)=N_B-K*(C_B-1)
        \]
		
		Solve for K:
		\[
			K=\frac{N_A-N_B}{C_A-C_B}
        \]
		
		
		Proportionality means every party has the same number of voters per candidate:
		
		\[
		\frac{N_A}{C_A}=\frac{N_B}{C_B}=\frac{N_t}{C_t}
		\]
		Do algebra:
		\[
        \begin{align}
			K & =\frac{N_A-N_B}{C_A-C_B}=\frac{C_A\frac{N_t}{C_t}-C_B\frac{N_t}{C_t}}{C_A-C_B}=\frac{C_A-C_B}{C_A-C_B}\frac{N_t}{C_t}=\frac{N_t}{C_t}=\frac{\text{voters}}{\text{seats}} \nonumber\\
			keep & =\frac{\text{voters}}{\text{seats}} \nonumber
        \end{align}
        \]
		So we know we have a proportional system.
      </p>
      <h3> Finishing the Model: Similarity </h3>
      <p>
        What if the voters don't fall into parties?
      </p>
      <p>
	    A party is just a group of people who vote the same.  Take an example.  Say rep A and B say they are from different parties.  What if a voter votes for both?  How do we account for proportionality?
		</p>
        <p>
		
		\[
		\text{The ballot of a voter for A and B.} \\
		\begin{bmatrix}
		A: & 1 \\
		B: & 1 
		\end{bmatrix}
		\]
		</p>
        <p>
		This voter voted for rep A and rep B.  Now look at all the ballots of two more voters.
		
		
		\[
		\text{A partisan voter for A} \\
		\begin{bmatrix}
		A: & 1 \\
		B: & 0 
		\end{bmatrix}
		\]
		
		
		\[
		\text{A partisan voter for B} \\
		\begin{bmatrix}
		A: & 0 \\
		B: & 1 
		\end{bmatrix}
		\]
		
		All 3 of these voters voted differently, but A and B are from just 2 parties, so how many parties are there?  Well, let's get rid of the idea of reps belonging to parties.  It's the voters who count.  We actually have 3 pools of voters.  Let's look at all the ballots together.
		
		\[
		\text{Three voter pools} \\
		\begin{bmatrix}
		A: & 1 & 1 & 0 \\
		B: & 0 & 1 & 1 
		\end{bmatrix}
		\]
		How do we account for this in our bookkeeping about kept votes?  1/3 of the votes for A or B were for both A and B.  So we reduce the number of kept votes to 1/3 of the usual.
		
		This measure is actually common.  It is called the Jaccard similarity.  Stated mathematically,
        \[
		\begin{align}
		\frac{1}{3} & = \frac{0 + 1 + 0}{1 + 1 + 1} \nonumber \\
s_{jk} & = \frac{\sum_{i \in Voters} min(b_{ij}, b_{ik})}{\sum_{i \in Voters} max(b_{ij}, b_{ik})} \text{ } \text{ } \text{ } \text{ (Similarity between rep j and rep k)}\nonumber \\
            keeps_{jk} & = keep * s_{jk} \nonumber
		\end{align}
        \]
        We have refined our model to maximize the following, called an objective function:
		\[
        \text{Maximize} \sum_{j \in Reps} tally_j * x_j - \sum_{j \in Reps,k \neq j} keeps_{jk} * x_j * x_k
        \]
        Remember the $x$ is binary and it indicates the winners.  This expression is just the sum of the table, so it's basically just letting us add up the tally and subtract the keeps for the winning reps. Also! <b>We have a new and better table to add up and maximize!  It is better because now we don't need parties!</b>
      </p>
	  <h3> The model is actually like a sudoku </h3>
      
      <p>
        There is a really easy way to visualize what the model is trying to do.  We reduced the problem to crossing out the rows and columns in a table.  Cross out the row and column for each rep that lost. Add the remaining tallies and keeps.
        \[
          \begin{bmatrix}
        10 & -4 & -3 &  0 & -1 \\
        -4 & 10 & -3 &  0 & -1 \\
        -3 & -3 &  8 & -2 &  0 \\
         0 &  0 & -2 & 11 &  0 \\
        -1 & -1 &  0 &  0 & 17 \\
          \end{bmatrix}
        \]
          Try to find the 4 winners by crossing out the losing rep's row and column.
      </p>
      <p>
      <img src="./crossout.png" align="center">
      </p>
      <p>
      The solution is to cross out the 3rd rep's row and column.  He had the lowest tally overall and he also overlapped in similarity with most of the other reps, so basically his territory was covered better by the other reps.
      </p>
	  <h3>Formal Model</h3>
      <p>
        To sum up, the model has variables $x_j$ that work with a table of measurements.  We maximize a sum with terms that multiply the variables once by each other (quadratic binary terms) and by the table of measurements.   There is a constraint on the sum of these variables.  Gurobi takes care of the search algorithm to find the maximum among a really large number of combinations (think factorial!).
      </p>
      <p>
        The problem is defined by the following model in the variable $x_j$ :

        \[
        \begin{array}{ll}
        \text{Maximize}   & {\displaystyle \sum_{j \in Reps} tally_j * x_j - \sum_{j \in Reps,k \neq j} keeps_{jk} * x_j * x_k } \\
		\\
        \text{Subject to} & {\displaystyle \sum_{j \in Reps} x_j} = \text{number of seats} \\
                          & x_j \in \{ 0, 1 \} \\
						  \\
        \end{array}
        \]
		\[
        \begin{array}{lrll}
        \text{Constants } & keeps_{jk} & = keep * s_{jk}\\
                          & s_{jk} & =  {\displaystyle \frac{\sum_{i \in Voters} min(b_{ij}, b_{ik})}{\sum_{i \in Voters} max(b_{ij}, b_{ik})} } & \text{Similarity between rep j and rep k}\\
                          & keep & = {\displaystyle \frac{\text{voters}}{\text{seats}} } & \text{Amount of ballots kept (if s=1, e.g. for clones)}\\
                          & tally_j & = {\displaystyle \sum_{i \in Voters} b_{ij} } & \text{Add up the ballots}\\
						  & b_{ij} & = {\displaystyle a_{ij} * \frac{1}{\max_{m \in Voters}{a_{mj}}}} &\text{Ballot} \\
						  & a_{ij} & = {\displaystyle \frac{1}{d_{ij}/10 + 1} } & \text{Inverting distance}\\
                          & d_{ij} &  & \text{Distance between voter i and rep j on the map}
        \end{array}
        \]

      </p>

    </div>
    <div class="example_section" id="implementation">
      <h2><a href="#implementation" name="implementation">Implementation</a></h2>
      <p>Below is an example implementation of the model with example data in
        Gurobi's Python interface:
      </p>
        <p>
            For the full implementation, see <a href="https://github.com/paretoman/searchingforparliament">https://github.com/paretoman/searchingforparliament</a>.
        </p>
<examplecode>
from gurobipy import *
import math
import numpy

# Problem data
voters = [[c1,c2] for c1 in range(10) for c2 in range(10)]
reps = [[f1*3+1.5,f2*3+1.7] for f1 in range(3) for f2 in range(3)]
numReps = len(reps)
numVoters = len(voters)

# Add variables
m = Model()
x = {}
for j in range(numReps):
    x[j] = m.addVar(vtype=GRB.BINARY, name="x%d" % j)

# Add constants
numWinners = 5
d = numpy.zeros((numVoters,numReps))
a = numpy.zeros((numVoters,numReps))
b = numpy.zeros((numVoters,numReps))
s = numpy.zeros((numReps,numReps))
t = numpy.zeros(numReps)

def distance(a,b):
  dx = a[0] - b[0]
  dy = a[1] - b[1]
  return math.sqrt(dx*dx + dy*dy)

for i in range(numVoters):
    for j in range(numReps):
        d[i,j] = distance(voters[i], reps[j])

a = 1 /( d/10 + 1 )

for i in range(numVoters):
	b[i,:] = a[i,:] / max(a[i,:])

def jaccard_similarity(a,b):
    return numpy.sum(numpy.minimum(a,b)) / numpy.sum(numpy.maximum(a,b))

for j in range(numReps):
    for k in range(numReps):
        s[j,k] = jaccard_similarity(b[:,j],b[:,k])
    t[j] = sum(b[:,j])
keep = numVoters / numWinners

m.update()

# Add constraints
m.addConstr(quicksum(x[j] for j in range(numReps)) == numWinners)

d_obj = LinExpr()
for j in range(numReps):
    d_obj += t[j]*x[j]
    for k in range(numReps):
        if k != j:
            d_obj += -keep*s[j,k]*x[j]*x[k]

m.setObjective( d_obj , GRB.MAXIMIZE)

m.optimize()

# Output
print(["%d" % x[j1].X for j1 in range(9)])

</examplecode>
    </div>
    <div class="example_section" id="demo">
      <h2><a href="#demo" name="demo">Live Demo</a></h2>

      <p>
        Below is a visualization of our example. We are using the
        location data from <a href="#geolytix">GeoLytix</a> for a large
        supermarket chain in the UK, and visualizing its outlets in
        Northern England. (This is an approximation to population distribution.)
      </p>

      <p>
        The voters are represented by:
        <svg height="20" width="20">
      <circle cx="10" cy="15" r="3" fill="black" opacity=".5" />
    </svg>
      </p>

      <p>
        By clicking the map you can add <em>potential</em> rep locations.
        These are drawn as:
        <svg height="20" width="20">
      <circle cx="10" cy="10" r="8" stroke="black" stroke-width="1" fill="white" />
    </svg>
      </p>
      <p>
        Click "Compute Winners" to find the reps who will win. These will be drawn as:
        <svg height="20" width="100">
      <circle cx="10" cy="10" r="8" stroke="#000099" stroke-width="3" fill="blue" />
          <circle cx="30" cy="10" r="8" stroke="#006600" stroke-width="3" fill="green" />
          <circle cx="50" cy="10" r="8" stroke="#990000" stroke-width="3" fill="red" />
          <circle cx="70" cy="10" r="8" stroke="#999900" stroke-width="3" fill="yellow" />
          <circle cx="90" cy="10" r="8" stroke="#404040" stroke-width="3" fill="gray" />
    </svg>
      </p>

      <p>
        A few potential rep locations have already been set up, but
        you can add more by clicking the screen.
      </p>
	  
	  
	  		<aside style="width:150px">
		<div id="options" style="display:none">
		<form>
		<fieldset>
		<legend>Keeps:</legend>
		<input type="range" min = 500000 max = 3000000 step = 500000 id="cost" value="1000000" oninput="outputUpdate(value)" class="slider-width" style="width:100px"> <br />
		<output for=cost id=costDisplay>1.0</output> Multiplier <br />
		<input class="op" type="radio" name="keeps" checked="true">	Seats Plus Zero <br />
		<input class="op" type="radio" name="keeps">	Seats Plus Half <br />
		<input class="op" type="radio" name="keeps">	Seats Plus One <br />
		</fieldset>
		<fieldset>
		<legend>Ballot:</legend>
		<input class="op"  checked="true"  type="checkbox">	Normalize <br />
		<input class="op" checked="true"  type="radio" name="ballots"> 	1 / Distance<br />
		<input class="op" type="radio" name="ballots">  Linear <br />
		<input class="op" type="radio" name="ballots">  Exponential <br />
		<input class="op" type="radio" name="ballots"> 	Threshold (todo) <br />
		</fieldset>
		<fieldset>
		<legend>Similarity Measure:</legend>
		<input class="op" type="radio" name="similarity" checked="true"> Jaccard<br />
		<input class="op" type="radio" name="similarity"> Cosine<br />
		<input class="op" type="radio" name="similarity"> L1<br />
		</fieldset>
		<fieldset>
		<legend>Computation:</legend>
		<input class="op" checked="true" type="radio" name="compute"> Our Binary Quadratic Problem as described above. <br />
		<input class="op" type="radio" name="compute"> STV <br />
		<input class="op" type="radio" name="compute"> Plurality Multiwinner <br />
		<input class="op" type="radio" name="compute"> Schulze STV (todo)<br />
		<input class="op" type="radio" name="compute"> Meeks STV <br />
		<input class="op" type="radio" name="compute" id="openstv"> OpenSTV (todo)
		<select id="stvtype" name="stvtype" onclick="selectOpenstv()">
			<option value="Approval">Approval</option>
			<option value="Borda">Borda</option>
			<option value="Bucklin">Bucklin</option>
			<option value="CambridgeSTV">CambridgeSTV</option>
			<option value="Condorcet">Condorcet</option>
			<option value="Coombs">Coombs</option>
			<option value="ERS97STV">ERS97STV</option>
			<option value="FTSTV">FTSTV</option>
			<option value="GPCA2000STV">GPCA2000STV</option>
			<option value="IRV">IRV</option>
			<option value="MeekQXSTV">MeekQXSTV</option>
			<option value="MeekSTV">MeekSTV</option>
			<option value="NIrelandSTV">NIrelandSTV</option>
			<option value="QPQ">QPQ</option>
			<option value="RTSTV">RTSTV</option>
			<option value="SNTV">SNTV</option>
			<option value="ScottishSTV">ScottishSTV</option>
			<option value="SuppVote">SuppVote</option>
			<option value="WarrenQXSTV">WarrenQXSTV</option>
			<option value="WarrenSTV">WarrenSTV</option>
		</select> <br />
		<input class="op" type="radio" name="compute"> Clustering like original<br />
		<input class="op" type="radio" name="compute"> A new formulation (working on it) 
	    </fieldset>
		<fieldset>
		<legend>Map:</legend>
		<input type="range" min = .1 max = 1 step = .1 id="zoom_id" value="1" oninput="updateZoom(value)" class="slider-width" style="width:60px">Zoom<br />
		<input type="range" min = -1 max = 1 step = .1 id="xshift_id" value="0" oninput="updateXshift(value)" class="slider-width" style="width:60px">X<br />
		<input type="range" min = -1 max = 1 step = .1 id="yshift_id" value="0" oninput="updateYshift(value)" class="slider-width" style="width:60px">Y<br />
		</fieldset>
		</form>
		</div>
	    </aside>
	  
      <div id="demoarea">
      </div>
	  
      <div id="spinnerdiv">
      </div>
	  <p>
      <button class="pure-button" onclick="compute()">Compute Winners</button>
      <button onclick="restart()">Restart</button>
	  <button class="pure-button" onclick="toggle_options()">Beast Mode</button>
	  <button class="pure-button" onclick="toggle_div()">Gurobi Log</button>
	  </p>
	  
      <p>
          <script>
			var cost;
			var numberOfWinners;
			function outputUpdate(value) {
			  document.querySelector('#costDisplay').value = value/1000000;
			}
			function numberOfWinnersUpdate(value) {
			  document.querySelector('#numberOfWinnersDisplay').value = value;
			}
			function updateZoom(value) {
			  zoomit = value;
			  draw_map();
			}
			function updateXshift(value) {
			  xshift = value;
			  draw_map();
			}
			function updateYshift(value) {
			  yshift = value;
			  draw_map();
			}
			function selectOpenstv() {
			document.querySelector('#openstv').checked = true;
			}
		  </script>  
		<input type="range" min = 1 max = 20 step = 1 id="numberOfWinners" value="5" oninput="numberOfWinnersUpdate(value)" class="slider-width" style="width:200px">
		<output for=numberOfWinners id=numberOfWinnersDisplay>5</output> Winners <br />

      </p>

      <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
      <script>
        function toggle_div() {
          var logfile = d3.select('#logfile');
          if (logfile.style("display") === "none") {
            logfile.style("display", "block");
          } else {
            logfile.style("display", "none");
          }

        }
		function toggle_options() {
          var optionsdiv = d3.select('#options');
          if (optionsdiv.style("display") === "none") {
            optionsdiv.style("display", "block");
          } else {
            //optionsdiv.style("display", "none"); //actually we don't want to cause confusion.  If you activate beast mode, you can't go back.
          }

        }
      </script>

      <examplecode id=logfile>
      </examplecode>

      
    </div>
	
	<p>
        <button id="morebutton" class="pure-button" onclick="toggle_readmore()">Read More</button>
      </p>


      <script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
      <script>
		function toggle_readmore() {
          var readmorediv = d3.select('#readmore');
          readmorediv.style("display", "block");
          var mb = d3.select('#morebutton');
          mb.style("display", "none");

        }
      </script>
	<div id="readmore" style="display:none">
	
     <p>
		There is also a beast mode where you can see different computations.  STV is included.  <a href="https://www.opavote.com/methods/single-transferable-vote">OpenSTV's implementations</a> are there.  There is a clustering computation similar to the project this was forked from.  And I am working on a new optimization based on a form of reweighted range voting (as of now it takes too long, maybe about a minute to run).  Also, there are different ballot types, an option for disabling normalization, an option for adding a +1 to the seats. Also, there are different similarity measures.  Also, you can change the amount of keeps to see how it allows for a proportional distribution of winners.
      </p>
	  <p style="font-size:8px">
        <a name="geolytix">Location data:</a>
        <a href="http://geolytix.co.uk/downloads/OpenSupermarkets.zip">Supermarket
        locations &copy; GeoLytix</a> copyright and database right 2014.
      </p>
    <div class="example_section" id="try">
      <h2><a href="#try" name="try">How to use Gurobi</a></h2>
      <p> Here is a link to Gurobi.  I kept it here because I forked this project from Emilien Dupont (on <a href="https://github.com/EmilienDupont/facilityLocation">github</a> and hosted as <a href="http://examples.gurobi.com/facility-location/"> a featured example on Gurobi's website</a>)
      </p>
      <p>
      I suggest using conda to install it.  And then there is a license to download, so you have to make an account on the gurobi website.  I used Python 2.
      </p>
      <div class="col_5 column">
        <a href="http://www.gurobi.com/downloads/evaluation-request">
          <button class="red stack-button">
            <i class="fa fa-lg fa-line-chart"></i>
            Commercial Users: Free Evaluation Version
          </button>
        </a>
      </div>
      <div class="col_5 column">
        <a href="http://www.gurobi.com/downloads/download-center">
          <button class="red stack-button">
            <i class="fa fa-lg fa-line-chart"></i>
            Academic Users: Free Academic Version
          </button>
        </a>
      </div>
      
      <div class="example_section" id="thoughts">
      <h2>Here's my thoughts.</h2>
      <p>
      It turns out I finally invented a good voting system.  So, how did I come up with it?  Well, I had thought of it before but couldn't work out the math.  It is the same as STV because it has a quota.  It is different than STV because it searches for the best combination of candidates that would maximize voter support for the winners.  
        </p>
        <p>
        I didn't think it would work.  I thought I was over-penalizing.  However, I realized that I could set the quota so that it optimized the number of candidates coming from a voter base.  The optimization is for proportionality.  I tried to use the same quota as STV's droop quota: number of voters over number-of-seats-plus-1.  
        </p>
        <p>
        Some things to change:  I'm not sure exactly what the quota should be because I'm not sure how they'll actually vote.  Right now, I have put them as all voting depending on their distance from a candidate.  Maybe I would choose a different function.  Maybe voters would want to maximize the range of their vote.  Maybe they would have just two levels of support, high and low, and they would change their threshold depending on who is running and who other people are voting for.
        </p>
        <p>
        Things to do.
        </p>
        <p>
          <ul><li>compare to clustering
        </li><li>normalize votes
        </li><li>try exponential choice function
        </li><li>try linear choice function
        </li><li>try threshold choice function
        </li><li>add STV comparison
        </li><li>add CPO-STV comparison
        </li><li>far future: put this into ncase's better ballot.
        </li><li>far future: yee diagram in background
        </li><li>explanation: what is the incentive of the voters to vote honestly?  Couldn't they find a way to avoid penalties by only supporting one candidate?  Isn't that strategy also applicable to STV?
        </li></ul>
          </p>
        <p>
        So basically what I was thinking was to write out a matrix of the penalties.  Then show that the penalties lead to a correct number of representatives for this voter-base.  
        </p>
        <p>
        In clustering, voters dont have influence outside their cluster.  In this penalty system, they can have negative influence if they get too many representatives... maybe.. but they would never get too many
        </p>
        <p>
        I need to motivate this with the idea of search.  There is depth-first, which is greedy and assigns the single candidates with the highest vote counts first.  Standard STV does this kind of depth-first search.  In STV, if more people like a candidate than the quota, then those people can get their second choices as well.  This is like at-large voting, except after your candidate gets a seat, part of your vote stays with them and only part of it gets to go to a second candidate.  This kind of division of the vote can be accomplished by subtracting the "kept" votes from the total vote count.  This avoids overcounting.
        </p>
        <p>
        The algorithm searches through all the possible combinations of seat assignments for the candidates.  It tries to maximize the number of voters who support the winning candidates.  It avoids double-counting in the same way as STV.  It keeps some of the votes for similar candidates.
        </p>
        <p>
        Basically, this cosine similarity is a measure of an angle.  It is not a typical angle.  It is not in 2 dimensions.  It is actually in many more dimensions, as many dimensions as there are candidates.  Still, the same idea holds in 2 dimensions that the more aligned 2 candidates are, the bigger the cosine similarity.  It ranges from 0 for candidates that have nothing in common to 1 for identical "clone" candidates.
        </p>
        <p>
        This information gets put into the problem definition table by simply multiplying each entry by cosine similarity.  Even the diagonals work! It's actually pretty easy.
        </p>
        <p>

        Now we just tell the optimization software to pick the 5 best rows and columns that have the biggest sum.  Those are the best winners.
        </p>
        <p>
        You can see that some areas have 2 candidates close together.  Sometimes a cluster of voters is big enough and supportive enough (close to the candidates), to elect 2 candidates.
        </p>
        <p>
        Of course there are details I left out.
        </p>
        <p>
        These are just my thoughts.
        </p>
		<p>
		So What?
		</p>
		<p>
		Distance is good, 2D is great.  Let's think about the 3rd Dimension.  What would it be?  It doesn't have to be distance.  It can be political affiliation.  Now, the 4th.  It can be a particular issue.  And we can have as many dimensions as their are issues  and there won't be any more wedge issues that keep you stuck in a 1-dimensional partisan left-right line.
		</p>
		</div>
	  
	  
    </div>
    </div>

    <div style="min-height:100px"></div>

<!--[if gt IE 8]><!--><script src="//ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script><!--<![endif]-->
<script src="jquery.nav.js"></script>
<script>
  $(document).ready(function() {
  console.log('calling onePageNav');
  $('#nav').onePageNav({scrollOffset:120});
  });
</script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.5/d3.min.js"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/spin.js/1.2.7/spin.min.js"></script>
<script>

// Hide Log File intially
d3.select('#logfile').style("display", "none");

//Width and height
var width = 800;
var height = 500;
var padding = 30;
var miles_per_px = 0.19;
var price_per_px = 3*miles_per_px;
var alpha = 5*365*price_per_px; // Consider the cost over 5 years
alpha = alpha * 1754385.964912 * 0.000548 // let's change alpha for "keep"
alpha = 1000100
alpha = 1000000
var spinner;

var svg = d3.select("#demoarea")
              .append("svg")
              .attr("width", width)
              .attr("height", height);

// Potential sites for facilities
var sites = [[.3*width, .8*height], [.4*width, .3*height], [516.40625, 380.34375],
             [486.40625, 55.34375], [766.40625, 179.34375], [728.40625, 439.34375]];

var cost = parseFloat(document.getElementById("cost").value)/alpha;

var charge = d3.range(sites.length).map(function(d) { return cost; });


// G object for background
var backgroundG;

// G object for map
var mapG;

// G object for animations
var animationG;

// G object for sites
var sitesG;

// G object for points
var circleG;

// G object for voronoi
var pathG;

// G object for facilities
var facilitiesG;

// G object for location names
var locationG;

// G object for clickable areas
var clickableG;

// G object for spinner
var spinnerG;

var zoomit = 1;
var xshift = 0;
var yshift = 0;
var projection;
var path;
var vertices;

var places;
var counties;



function draw_map() {
    
// G object for background
backgroundG = svg.append("g");

// G object for map
mapG = svg.append("g");

// G object for animations
animationG = svg.append("g");

// G object for sites
sitesG = svg.append("g");

// G object for points
circleG = svg.append("g");

// G object for voronoi
pathG = svg.append("g");

// G object for facilities
facilitiesG = svg.append("g");

// G object for location names
locationG = svg.append("g");

// G object for clickable areas
clickableG = svg.append("g");

// G object for spinner
spinnerG = svg.append("g").attr("id", "spinid");


backgroundG.append("rect")
           .attr("x", 0).attr("y", 0)
           .attr("width", width).attr("height", height)
           .attr("fill", "#A3CCFF"); // "#66B2FF"
		   

sitesG.selectAll("circle")
       .data(sites)
       .enter()
       .append("circle")
       .attr("cx", function(d) { return d[0]; })
       .attr("cy", function(d) { return d[1]; })
       .attr("class", "site")
       .attr("r", 5);

var mapColors = [];
var maxRed = 247, minRed = 116;
var maxGreen = 252, minGreen = 196;
var maxBlue = 245, minBlue = 118;
var maxRed = 247, minRed = 116+100;
var maxGreen = 252, minGreen = 196+50;
var maxBlue = 245, minBlue = 118+100;
var maxRed = 247, minRed = 203;
var maxGreen = 252, minGreen = 230;
var maxBlue = 245, minBlue = 163;
var numColors = 40;
for (var i = 0; i < numColors; i++) {
  var red = String( Math.round( minRed + (maxRed - minRed)*i/numColors ) );
  var green = String( Math.round( minGreen + (maxGreen - minGreen)*i/numColors) );
  var blue = String( Math.round( minBlue + (maxBlue - minBlue)*i/numColors ) );
  mapColors.push( "rgb(" + red + "," + green + "," + blue + ")");
}


	projection = d3.geo.albers()
		.center([.2, 53.6 + yshift*3])
		.rotate([2.4 + xshift* -3, 0])
		.parallels([50, 60])
		.scale(1200 * 20 * zoomit)
		.translate([width / 2 , height / 2]);
	path = d3.geo.path()
		.projection(projection);

	d3.json("UKwithCounties.json", function(error, uk) {
	  d3.json("supermarket.json", function(supermarket) {
		vertices = [];
		// Set up map of UK
		places = topojson.feature(uk, uk.objects.placesUK);
		counties = topojson.feature(uk, uk.objects.ukcounties).features;

		mapG.selectAll("path")
			.data(counties)
			.enter()
			.append("path")
			.attr("d", path)
			.attr("fill", function(d,i) { return mapColors[i % 10 + 10]; })
			//.attr("fill", function(d,i) { return mapColors[i % 9]; })
			//.attr("fill", function(d,i) { return mapColors[i%3+7]; })
			//.attr("fill","#CBE6A3")
			//.attr("stroke", "rgb(150,150,150)")
			;

		clickableG.selectAll("path")
			.data(counties)
			.enter()
			.append("path")
			.attr("d", path)
			.attr("opacity", 0)
			.on("mousedown", addPoint);

		locationG.append("path")
				 //.datum(places)
				 .attr("d", path)
				 .attr("class", "place");

		locationG.selectAll(".place-label")
				.data(places.features)
				.enter().append("text")
				.attr("class", "place-label")
				.attr("transform", function(d) { return "translate(" + projection(d.geometry.coordinates) + ")"; })
				.attr("x", function(d) { return d.geometry.coordinates[0] > -1 ? 6 : -6; })
				.attr("dy", ".35em")
				.style("text-anchor", function(d) { return d.geometry.coordinates[0] > -1 ? "start" : "end"; })
				.text(function(d) { return d.properties.name; })
				.attr("font-family", "Helvetica Neue")
				.attr("font-size", 15)
				.attr("font-weight", 400);

		// Set up supermarket locations
		// Add locations to vertices array
		circleG.selectAll("circle")
			   .data(supermarket)
			   .enter()
			   .append("circle")
			   .filter(function(d) {
				  var loc = projection([d.LongWGS84, d.LatWGS84]);
				  return ( loc[0] >= 0 && loc[0] <= width && loc[1] >= 0 && loc[1] <= height);})
			   .attr("cx", function (d) { var loc = projection([d.LongWGS84, d.LatWGS84]);
										  vertices.push([parseFloat(loc[0]), parseFloat(loc[1])]);
										  return loc[0]; })
			   .attr("cy", function (d) { var loc = projection([d.LongWGS84, d.LatWGS84]);
										  return loc[1]; })
			   .attr("r", 2)
			   .attr("class", "client");

		console.log('number of vertices', vertices.length);
	  });
	});
	
	if (zoomit != 1 || xshift !=0 || yshift !=0) restart(); // really I'd like to keep some initial points but it wasn't working.
}

draw_map();

function addPoint() {
  facilitiesG.selectAll("circle").remove("circle");
  animationG.selectAll("circle").remove("circle");
  pathG.selectAll("line").remove("line");

  var point = d3.mouse(this);
  console.log('point', point);
  sites.push(point);
  sitesG.append("circle")
         .attr("cx", point[0])
         .attr("cy", point[1])
         .attr("class", "site")
         .attr("r", 5);
  charge.push(cost);

  // Add animation
  animationG.selectAll("circle").remove("circle");
  var anim = animationG.append("circle")
                        .attr("cx", point[0])
                        .attr("cy", point[1])
                        .attr("r", 0)
                        .attr("fill", "black");

  anim.style("opacity", .5)
      .transition()
      .style("opacity", 0)
      .attr("r", 20)
      .duration(200)
      .ease("out");
}

function compute() {

  if (sites.length < 1) {
    alert("Add potential sites to compute the optimal facility locations!");
    return;
  }

  facilitiesG.selectAll("circle").remove("circle");
  animationG.selectAll("circle").remove("circle");
  pathG.selectAll("line").remove("line");

  // Show loading screen
  spinnerG.append("rect")
          .attr("x", 0).attr("y", 0)
          .attr("width", width).attr("height", height)
          .attr("fill", "white")
          .attr("opacity", .5);

  spinnerG.append("text")
          .attr("x", width/2)
          .attr("y", .4*height)
          .attr("font-size", 25)
          .attr("font-family", "Helvetica Neue")
          .attr("font-weight", 400)
          .attr("text-anchor", "middle")
          .text("Computing...");

  var target = document.getElementById('demoarea');
  spinner = new Spinner({left: '375%'}).spin(target);

  // options
  cost = parseFloat(document.getElementById("cost").value)/alpha;
  numberOfWinners = parseFloat(document.getElementById("numberOfWinners").value);
  stvtype = document.getElementById("stvtype").value;
  charge = [];
  charge.push(numberOfWinners);
  charge.push(cost);
  charge.push(stvtype);
  var ops = document.getElementsByClassName('op');
  for(var i = 0; i < ops.length; i++){
	charge.push( 0 + ops[i].checked);
  }
  
  d3.json('facility.py')
    .header('Content-Type', 'application/json')
    .post(JSON.stringify({'clients': vertices,
                          'facilities': sites,
                          'charge': charge}), serverResponse);
}

function serverResponse(error, data) {
  console.log('serverResponse');
  console.log('data', data);

  // Remove loading screen
  spinnerG.selectAll("rect").remove("rect");
  spinnerG.selectAll("text").remove("text");
  spinner.stop();

  if (!error) {
      if ('solution' in data) {
          // Import solution and put it into correct format
          var solution = data['solution'];
          if (solution[0] === "error") {
            alert("10 second solve time limit exceeded. Reduce the number of the candidate facilities.");
            return;
          }
          var solution1 = solution[0]; // Facilities to open
          var solution2 = solution[1]; // Edges to draw
          var logMsg = solution[2]; // Log message to display

          d3.select('#logfile').html(logMsg);

          var facilities = [];

          for (var i = 0; i < solution1.length; i++) {
            facilities.push(sites[solution1[i]]);
          }

          facilitiesG.selectAll("circle").remove("circle");
          animationG.selectAll("circle").remove("circle");

          var faci = facilitiesG.selectAll("circle")
                     .data(facilities)
                     .enter()
                     .append("circle")
                     .attr("cx", function(d) { return d[0]; })
                     .attr("cy", function(d) { return d[1]; })
                     .attr("class", function(d, i) { return "c" + i % 5; })
                     .attr("r",60)
                     .attr("stroke-width", 2);

          var anim = animationG.selectAll("circle")
                     .data(facilities)
                     .enter()
                     .append("circle")
                     .attr("cx", function(d) { return d[0]; })
                     .attr("cy", function(d) { return d[1]; })
                     .attr("class", function(d, i) { return "c" + i % 5; })
                     .attr("r",0)
                     .attr("stroke-width", 0);

          faci.style("opacity", 0)
              .style("stroke-opacity", 0)
              .transition()
              .style("opacity", 1)
              .style("stroke-opacity", 1)
              .attr("r", 6)
              .duration(500)
              .delay(function(d, i) { return i*100 });

          anim.style("opacity", .5)
              .style("stroke-opacity", .5)
              .transition()
              .style("opacity", 0)
              .style("stroke-opacity", 0)
              .attr("r", 30)
              .duration(500)
              .ease("out")
              .delay(function(d, i) { return i*100 + 300});

          pathG.selectAll("circle").remove("circle");

          var connections = pathG.selectAll("circle")
                                 .data(solution2)
                                 .enter()
								 .append("circle")
								 .attr("r", 2)
								 .attr("cx", function(d) { var loc = vertices[d[0]]; return loc[0]; })
                                 .attr("cy", function(d) { var loc = vertices[d[0]]; return loc[1]; })
                                 .attr("class", function(d) {   var n = solution1.indexOf(d[1]);
                                                                return "v" + n % 5; })
                                 .attr("opacity", 0);

          connections.transition()
                     .attr("opacity", .6)
                     .duration(500)
                     .delay(0);
		  circleG.transition()
                     .attr("opacity", 0)
                     .duration(500)
                     .delay(0);
		  
        }
      }
}


function restart() {
  sitesG.selectAll("circle").remove("circle");
  facilitiesG.selectAll("circle").remove("circle");
  animationG.selectAll("circle").remove("circle");
  pathG.selectAll("circle").attr("class", "client").attr("r",2);
  sites = [];
}

</script>


